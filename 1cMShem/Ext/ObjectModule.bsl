//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//    ЧАСТЬ 1. МЕТОДЫ ШИРОКОГО ПОТРЕБЛЕНИЯ(27).

//    1.1. БАЗОВЫЕ МЕТОДЫ (10 функций).
//    Независимые, построены на своих простых алгоритмах.

//Функция Стр_Дополнить(ВходСтр="",Длина=0,Симв=" ",Слева=Ложь)
//Возвращает строку, полученную дополненеием (ВходСтр) 
//справа или слева символами (Симв) до длины (Длина).
Функция Стр_Дополнить(ВходСтр="",Длина=0,Симв=" ",Слева=Ложь) Экспорт 
	Кс=СтрДлина(Симв); Д=Число(Длина)-СтрДлина(ВходСтр); Если (КС=0) или (Д<=0) тогда Возврат ВходСтр; КонецЕсли;
	К=Цел(Д/Кс); Стр=Лев(Симв,Д%Кс); Для Сч=1 по К цикл Стр=Симв+Стр; КонецЦикла;
	Возврат ?(Слева,Стр+ВходСтр,ВходСтр+Стр);
КонецФункции //Стр_Дополнить(ВходСтр="",Длина=0,Симв=" ",Справа=Истина)

//Функция Стр_Инверс(ВходСтр)
//Возвращет "инверсию" строки (с символами справа-налево).
Функция Стр_Инверс(ВходСтр) Экспорт 
	Дл=СтрДлина(ВходСтр); Стр=""; Для Сч=1 по Дл цикл Стр=Сред(ВходСтр,Сч,1)+Стр; КонецЦикла;
	Возврат Стр;
КонецФункции //Функция Стр_Инверс(ВходСтр)	

//Функция Стр_Коды(Вход,Нач=0,Кон=10000000,МассивКодов="")
//Возвращает строку с кодами символов строки через ",". 
//ВХОД:
//  Вход  - Строка
//  Нач   - начальная позиция;
//  Кон   - конечная позиция;
//ВЫХОД:
//  МассивКодов - массив с кодами.
//
Функция Стр_Коды(ВходСтр,Нач=0,Кон=10000000,МассивКодов="") Экспорт
	Масс=Новый Массив;  Если Кон<Нач тогда Возврат ""; КонецЕсли; 
	Вход=""+ВходСтр; Дл0=СтрДлина(Вход); Кон=Мин(Дл0,Кон); Стр2=СРед(Вход,Нач,Кон-Нач+1); Дл=СтрДлина(Стр2); Стр="";
	Для сч=1 по Дл цикл К=КодСимвола(Стр2,Сч); Стр=Стр+?(Сч=1,"",",")+К; Масс.Добавить(К); КонецЦикла;
    МассивКодов=Масс; Возврат Стр;
КонецФункции //Стр_Коды(Вход,Нач=0,Кон=10000000,МассивКодов="")

//Функция Стр_Символы(Вход,Нач=0,Кон=10000000,МассивСимволов="")
//Возвращает строку символов, полученных из кодов (Вход).
//ВХОД:
//  Вход  - строка с Кодами символов (через ",") или массив с Кодами
//  Нач   - начальный номер кода в строке или нач. индекс массива;
//  Кон   - конечный номер кода в строке или кон. индекс массива;
//ВЫХОД:
//  МассивСимволов - массив с символами.
//
Функция Стр_Символы(Вход,Нач=0,Кон=10000000,МассивСимволов="") Экспорт
	Масс=Новый Массив;  Если Кон<Нач тогда МассивСимволов=Масс; Возврат ""; КонецЕсли; 
	Ном=0; ТипВх=ТипЗнч(Вход); Стр="";
	Если ТипВх=Тип("Массив") тогда К=Мин(Вход.Количество()-1,Кон); 
		Если Нач>К тогда МассивСимволов=Масс; Возврат Стр; КонецЕсли;
		Для сч=Нач по К цикл С=Символ(Стр_Число(Вход[Сч])); Стр=Стр+С; Масс.Добавить(С); КонецЦикла;			
	Иначе Вх=СтрЗаменить(""+Вход," ",""); Дл=СтрДлина(Вх); 
		Если Прав(Вх,1)=")" тогда Вх=Лев(Вх,Дл-1); КонецЕсли; Если Лев(Вх,1)="(" тогда Вх=Сред(Вх,2); КонецЕсли;
		Для сч=1 по 10000000 цикл Ном=Ном+1; Н=Найти(Вх,","); Фр=?(Н=0,Вх,Лев(Вх,Н-1)); Вх=?(Н=0,"",Сред(Вх,Н+1)); 
			Если Ном>=Нач тогда С=Символ(Стр_Число(Фр,Истина)); Стр=Стр+С; Масс.Добавить(С); КонецЕсли; 
			Если (Н=0) или (Ном=К) Тогда Прервать; КонецЕсли;	
		КонецЦикла;	
	КонецЕсли;	
    МассивСимволов=Масс; Возврат Стр;
КонецФункции //Стр_Символы(Вход,Нач=0,Кон=10000000,МассивСимволов="")

//Функция Стр_ЗаменитьСимволы(ВходСтр,ЗаменяемыеСимволы="",ЗаменяющиеСимволы="",НачПозиция=1,КонПозиция=10000000)
//Возвращает строку. 
//В исходной строке между позициями - (НачПозиция) и 
//(КонПозиция_ - символы из параметра (ЗаменяемыеСимволы) замещаются 
//соответствующими п/п символами из параметра (ЗаменяющиеСимволы). 
Функция Стр_ЗаменитьСимволы(ВходСтр,ЗаменяемыеСимволы="",ЗаменяющиеСимволы="",НачПозиция=1,КонПозиция=10000000) Экспорт
	Дл=СтрДлина(ЗаменяемыеСимволы); ДлВ=СтрДлина(ВходСтр); Кон=Мин(КонПозиция,ДлВ); Если Кон<НачПозиция тогда Возврат ВходСтр; КонецЕсли; 
	Стр1=Лев(ВходСтр,НачПозиция-1); Стр3=Сред(ВходСтр,Кон+1); Стр2=СРед(ВходСтр,НачПозиция,Кон-НачПозиция+1);
	Для сч=1 по Дл цикл Стр2=СтрЗаменить(Стр2,Сред(ЗаменяемыеСимволы,Сч,1),Сред(ЗаменяющиеСимволы,Сч,1)); КонецЦикла;	
	Возврат Стр1+Стр2+Стр3;	
КонецФункции //Стр_ЗаменитьСимволы(ВходСтр,ЗаменяемыеСимволы="",ЗаменяющиеСимволы="",НачПозиция=1,КонПозиция=10000000)

//&НаСервереБезКонтекста
//Функция Стр_УниСорт(ВхСтр="",Уникальность=Истина,Сортировать=Истина)
//Возвращает строку:
//Если Уникальность=Истина - с уникальными (в единственном числе) 
//   символами, присутствующими (в любом количестве) во ВхСтр. 
//Если Сортировать=Истина - символы в выходной строке
//   сортируются согласно Уникодам.
Функция Стр_УниСорт(ВхСтр="",Уникальность=Истина,Сортировать=Истина)
	Если ВхСтр="" тогда Возврат ""; КонецЕсли; 
	Если (Не Уникальность) и (Не Сортировать)  тогда возврат ВхСтр; КонецЕсли;
	//
	Вых=""; Дл=СтрДлина(ВхСтр); Н=0;
	ТЗ=Новый ТаблицаЗначений; ТЗ.Колонки.Добавить("Ч"); ТЗ.Колонки.Добавить("Н");
	Для Сч=1 по  Дл цикл Н=Н+1; Стр=ТЗ.Добавить(); Стр.Ч=КодСимвола(ВхСтр,Сч); Стр.Н=Н; КонецЦикла;	
	Если Уникальность тогда ТЗ.Свернуть("Ч"); Если Сортировать тогда ТЗ.Сортировать("Ч"); КонецЕсли;
	Иначе  Если Сортировать тогда ТЗ.Сортировать("Ч,Н"); КонецЕсли;
	КонецЕсли;	
	Для каждого Стр из ТЗ цикл Вых=Вых+Символ(Стр.Ч); КонецЦикла;
	ТЗ="";
	Возврат Вых;
КонецФункции //Стр_УниСорт(ВхСтр="",Сортировать=Истина)

//&НаСервереБезКонтекста
//Функция Стр_Перекодировка(ВхСтр,СимволыСтроки="",СимволыКодировки="",ДлинаКода=0,Сортировка=Ложь;)
//Возвращает строку.
//Каждуй символ или набор символов входящей строки "ВхСтр" (из "СимволыСтроки")
//заменяется на набор символов или символ (из "СимволыКодировки").  
//Длина кода (разрядность перекодировки, или, говоря проще, сколько символов 
//заменяют 1 символ исходной строки СтрВх)) вычисляется функцией, но 
//может быть и задана - в этом случае функцией используется максимум из
//заданного и вычисленного значений.
//
///Функция "симметрична": вставляем вместо СтрВх - полученный выход, 
//вместо СимволыСтроки - СимволыКодировки, вместо СимволыКодировки - СимволыСтроки,
//ДлинаКода оставляем прежней - получаем на выходе СтрВх.
//ПРИМЕЧАНИЕ: для корректного "возврата" надо применять именно указанные параметры
//и именно для "первично" обработанной этой функцией строки! 
//
//ПРИМЕЧАНИЕ: Строка ЗаменяемыеСимволы должна содержать как минимум 
//все встречающиеся в СтрВх уникальные символы, не должно быть повторяющихся символов.
//Не должно быть повторяющихся символв и в строке СимволыКодировки.
//При первом применении к строке - длина строки СимволыСтроки должна быть больше или равна
//длине строки СимволыКодировки (или равна 0, если строка СимволыСтроки не задана!). 
//При "обратном" применении получается, естественно, наоборот.
//
//Если строка ЗаменяемыеСимволы не задана используются Уникоды (метод КодСимвола(...))
//(При "обратном" применении, естественно, должна быть не задана стр.СимволыКодировки).
//
//Если Сортировка=Истина, то символы в строке СимволыСтроки и в строке СимволыКодировки
//сортируются по порядку Уникодов (применяется функция Стр_УниСорт(...)).
//
//____________________________________________________________________
//ЗАГОТОВКИ СТРОК (отсортированы по Уникодам):
//
//0123456789                            //Цифры
//ЁАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ	    //Русские верхний регистр
//абвгдежзийклмнопрстуфхцчшщъыьэюяё     //Русские нижний регистры
//ЁАЕИОУЫЭЮЯ    БВГДЖЗЙКЛМНПРСТФХЦЧШЩЪЬ //Русские гласные и согласные верхний регистр
//аеиоуыэюяё   бвгджзйклмнпрстфхццчщъь  //Русские гласные и согласные нижний регистр
//ABCDEFGHIJKLMNOPQRSTUVWXYZ            //Латинские верхний регистр
//abcdefghijklmnopqrstuvwxyz            //Латинские нижний регистр
//AEIOU   BCDFGHJKLMNPQRSTVwXYZ         //Латинские  гласные и согласные верхний регистр
//aeiou   bcdfghjklmnpqrstvwxyz         //Латинские  гласные и согласные нижний регистр
//"#$%&()*+-/<=>@[\]^`{|}~№             //"Клавиатурные" знаки
// !,-.:;?                              //Знаки Препинания
//
//ПРИМЕР ПРИМЕНЕНИЯ: можно перевести "буквенную" строку в "цифровую" или в "двоичную". 
//Да много чего можно! 
//
Функция Стр_Перекодировка(ВхСтр,СимволыСтроки="",СимволыКодировки="",ДлинаКода=0,Сортировка=Ложь)
	//
	ДлВ=СтрДлина(ВхСтр); ДлК=СтрДлина(СимволыСтроки); ДлПК=СтрДлина(СимволыКодировки); СтрВых=""; 	
	СтрК=СимволыСтроки; Если Сортировка и ДлК тогда СтрК=Стр_УниСорт(СтрК); ДлК=СтрДлина(СтрК); КонецЕсли;
	СтрПК=СимволыКодировки; Если Сортировка и ДлПК тогда СтрПК=Стр_УниСорт(СтрПК); ДлПК=СтрДлина(СтрПК); КонецЕсли;
	//
	//Вычисляем количество разрядов перекодировки (длину кода):
	Если (ДлК=0) и (ДлПК=0) тогда ДлинаКода=1; Возврат ВхСтр; КонецЕсли;
	ДлК=?(ДлК=0,65536,ДлК); ДлПК=?(ДлПК=0,65536,ДлПК);
	Если (ДлК<2) или (ДлПК<2) тогда ДлинаКода=0; Возврат ВхСтр; КонецЕсли; 
	ДлКода=1+?(ДлК=ДлПК,0,?(ДлК>ДлПК,Цел(Log10(ДлК)/Log10(ДлПК)),Цел(Log10(ДлПК)/Log10(ДлК))));
	ДлинаКода=Макс(ДлКода,ДлинаКода);
	//
	//Длина СимволыСтроки равна длине СимволыКодировки
	//(близкий аналог - функция  Стр_ЗаменитьСимволы(...)):
	Если ДлК=ДлПК тогда 
		Для Сч=1 по ДлВ цикл С=Сред(ВхСтр,Сч,1); Н=Найти(СтрК,С); СтрВых=СтрВых+Сред(СтрПК,Н,1); КонецЦикла;	
		//	
	//Длина СимволыСтроки больше длины СимволыКодировки
	//("первичное" применение):
	ИначеЕсли ДлК>ДлПК тогда Д=ДлПК;
		Для Сч=1 по ДлВ цикл  С=Сред(ВхСтр,Сч,1); Н=?(ДлК=65536,КодСимвола(С,1),Найти(СтрК,С)); СтрС="";
			Для Сч1=1 по ДлинаКода цикл Н=?(Сч1=1,Н,Цел(Н/Д));
				Ч=Н%Д+1; Сим=Сред(СтрПК,Ч,1); СтрС=Сим+СтрС;		
			КонецЦикла;	
			СтрВых=СтрВых+СтрС;
		КонецЦикла;	
		//
	//Длина СимволыСтроки меньше длины СимволыКодировки
	//("обратное" применение):
	ИначеЕсли ДлК<ДлПК тогда Кол=ДлВ/ДлинаКода;
		Для Сч=1 по Кол цикл Н=0; Д=1;
			Для Сч1=-ДлинаКода по -1 цикл С=Сред(ВхСтр,(Сч-1)*ДлинаКода-Сч1,1);	
				Н1=Найти(СтрК,С)-1; Н=Н+(Н1*Д);	Д=Д*ДлК;
			КонецЦикла;	
			СтрВых=СтрВых+?(ДлПК=65536,Символ(Н),Сред(СтрПК,Н,1));
		КонецЦикла;	
	КонецЕсли;			
	//
	Возврат СтрВых;	
	//	
КонецФункции //Стр_Перекодировка(СтрВх,СимволыСтроки="",СимволыКодировки="")

//Функция Стр_ИзМассива(ВхМассив,Разделитель="",НачИндМассива=0,КонИндМассива=1000000000,ВыхМасс="")
//Создает строку из разделителя (Разделитель) и элементов 
//массива между (НачИндМассива) и (КонИндМассива).
Функция Стр_ИзМассива(ВхМассив,Разделитель="",НачИндМассива=0,КонИндМассива=1000000000,ВыхМасс="") Экспорт
	ВыхМасс=Новый Массив; Если ТипЗнч(ВхМассив)<>Тип("Массив") тогда Возврат ""; КонецЕсли;
	К=ВхМассив.Количество(); Если К=0 тогда Возврат ""; КонецЕсли;
	Кон=Мин(КонИндМассива,К-1); Нач=Макс(0,НачИндМассива); Если Нач>Кон тогда Возврат ""; КонецЕсли; Вых="";
	Для сч=Нач по Кон цикл Фр=ВхМассив[Сч]; Вых=Вых+?(Сч=Нач,"",Разделитель)+Фр; ВыхМасс.Добавить(Фр); КонецЦикла;
    Возврат Вых;
КонецФункции //Стр_ИзМассива(ВхМассив,Разделитель="",НачИндМассива=0,КонИндМассива=1000000000,ВыхМасс="")

//Функция Стр_НайтиВх(ВходСтр,Разделитель,Справа=Ложь,НачПозПоиска=Неопределено,ПозСледПоиска=0,ПозНачФрагмента=0,ДлинаФрагмента=0)
//Возвращает позицию следующего найденного разделителя.
//Аналог Найти(...). Но возможен поиск слева и справа 
//и с указанной позиции
//ВХОД:
//  ВходСтрок     - строка, в которой ведется поиск Разделителя;
//  Разделитель   - группа символов, разделяющих фрагменты строки;
//  Справа=Ложь   - поиск производиться слева направо (иначе - наоборот)
//  НачПозПоиска  - позиция, с которой следует начинать поиск;
//ВЫХОД:
//  ПозСледПоиска   - вычисленная нач. позиция следующего поиска;
//  ПозНачФрагмента - нач.поз.фрагмента строки до найденного разделителя;
//  ДлинаФрагмента  - Длина фрагмента строки до найденного разделителя;
//
//
//
Функция Стр_НайтиВх(ВходСтр,Разделитель,Справа=Ложь,НачПозПоиска=Неопределено,ПозСледПоиска=0,ПозНачФрагмента=0,ДлинаФрагмента=0) Экспорт
	ДлРазд=СтрДлина(Разделитель); Дл=СтрДлина(ВходСтр); П=0; Раз=""; 
	ПозТек=?(НачПозПоиска<>Неопределено,НачПозПоиска,?(Справа,Дл,1)); //ПозНачФрагмента=ПозТек;
	Если ПозТек=0 тогда СледПозПоиска=0; ПозНачФрагмента=0; ДлинаФрагмента=0; Возврат 0; КонецЕсли;
	Если Справа тогда 	//Ищем справа
		Для сч=-ПозТек по -1 Цикл С=Сред(ВходСтр,-Сч,1); Раз=С+Лев(Раз,ДлРазд-1); 
			Если СтрДлина(Раз)<ДлРазд тогда Продолжить; КонецЕсли;
			Если Раз=Разделитель тогда П=-Сч; Прервать; КонецЕсли;
		КонецЦикла;	
		ПозСледПоиска=?(П=0,0,П-1); ПозНачФрагмента=?(П=0,1,П+ДлРазд);		
		ДлинаФрагмента=ПозТек-ПозНачФрагмента+1; 	
	Иначе //Ищем слева	
		Для сч=ПозТек по Дл Цикл С=Сред(ВходСтр,Сч,1); Раз=Прав(Раз,ДлРазд-1)+С; 
			Если СтрДлина(Раз)<ДлРазд тогда Продолжить; КонецЕсли;
			Если Раз=Разделитель тогда П=Сч-ДлРазд+1; Прервать; КонецЕсли;
		КонецЦикла;	
		ПозСледПоиска=?(П=0,0,П+ДлРазд); ПозСледПоиска=?(ПозСледПоиска>Дл,0,ПозСледПоиска);	
		ПозНачФрагмента=ПозТек; ДлинаФрагмента=?(П=0,Дл-ПозТек+1,П-ПозТек);
	КонецЕсли;	
	Возврат П;
КонецФункции //Стр_СледРазд(ВходСтр,Разд,ПозТек=0,Справа=Ложь)

//Функция Стр_НайтиГр(ВходСтр,Фильтр,Справа=Ложь,НачПозПоиска=Неопределено,НомСтоп=Неопределено,ДлинаТекГруппы=0,НачСледГруппы=0,НомСледГр=0)
//Возвращает Номер Группировки текущей группы символов.
//Если не найдена группа символов, удовлетворяющих 
//хотя бы какому то из группирующих фильтров - возвращает 0;
//Возможен поиск слева и справа 
//ВХОД:
//  ВходСтрок     - строка, в которой ведется поиск (выявление)
//                  группы символов,относящихся к одной из группировок.
//  Фильтр        - Группа символов (или массив групп), определяющая
//                  (или определяющие) Группировку (Группировки);
//                  Первым символом должен быть "+"(вхождение) или
//                  "-"(не вхождение).
//  Справа=Ложь   - поиск производиться слева направо (иначе - наоборот)
//  НачПозПоиска  - позиция, с которой следует начинать поиск;
//  НомСтоп       - Возврат, если первый символ текущей группы относится 
//                  к группировке с номером НомСтоп;
//ВЫХОД:
//  ДлинаТекГруппы - Длина текущей группы;
//  НачСледГруппы  - нач.поз.Следующей группы;
//  НомСледГр      - Номер Группировки следующей группы символов;
Функция Стр_НайтиГр(ВходСтр,Фильтр,Справа=Ложь,НачПозПоиска=Неопределено,НомСтоп=Неопределено,ДлинаТекГруппы=0,НачСледГруппы=0,НомСледГр=0) Экспорт
	Вх=ВходСтр; ДлВх=СтрДлина(Вх); Нач=?(НачПозПоиска=Неопределено,?(Справа,ДлВх,1),НачПозПоиска); Г0=0; СтрГ=""; КГ=0;
	Если ТипЗнч(Фильтр)=Тип("Массив") тогда Фи=Фильтр иначе Фи=новый Массив; Фи.Добавить(Фильтр); КонецЕсли;
	//
	Если Справа тогда //Поиск справа 
		Для сч=-Нач по -1 цикл С=Сред(Вх,-Сч,1); Г=0; Есть=0;
			Для каждого Э из Фи цикл Г=Г+1;	Зн=Э; Фл=Лев(Зн,1); Зн=Сред(Зн,2);	Н=Найти(Зн,С);	//по фильтрам
				Если ((Н>0) и (Фл="+")) или ((Н=0) и (Фл="-")) тогда Есть=Г; Г0=?(Сч=-Нач,Г,Г0); Прервать; КонецЕсли;
			КонецЦикла;				
			Если Г0=НомСтоп тогда Возврат Г0; КонецЕсли;
			Если (Г0<>Есть) и (Сч>-Нач) тогда ДлинаТекГруппы=СтрДлина(СтрГ); НачСледГруппы=Нач-ДлинаТекГруппы; НомСледГр=Есть; Кг=КГ+1; Прервать; КонецЕсли; 			
			СтрГ=С+СтрГ; //пополняем текущую группу
		КонецЦикла; 
		Если (Сч=0) и (КГ=0) тогда ДлинаТекГруппы=Нач; КонецЕсли;
		Возврат Г0;
	Иначе	//Поиск слева		
		Для сч=Нач по ДлВх цикл С=Сред(Вх,Сч,1); Г=0; Есть=0;
			Для каждого Э из Фи цикл Г=Г+1;	Зн=Э; Фл=Лев(Зн,1); Зн=Сред(Зн,2);	Н=Найти(Зн,С);	//по фильтрам
				Если ((Н>0) и (Фл="+")) или ((Н=0) и (Фл="-")) тогда Есть=Г; Г0=?(Сч=Нач,Г,Г0); НомСледГр=Есть; Прервать; КонецЕсли;
			КонецЦикла;				
			Если Г0=НомСтоп тогда Возврат Г0; КонецЕсли;
			Если (Г0<>Есть) и (Сч>Нач) тогда ДлинаТекГруппы=СтрДлина(СтрГ); НачСледГруппы=Нач+ДлинаТекГруппы; Кг=Кг+1; Прервать;	КонецЕсли; 			
			СтрГ=СтрГ+С; //пополняем текущую группу
		КонецЦикла;
		Если (Сч=(ДлВх+1)) и (КГ=0) тогда ДлинаТекГруппы=ДлВх-Нач+1; КонецЕсли;
		Возврат Г0;
	КонецЕсли;	
КонецФункции //Функция Стр_НайтиВх(ВходСтр,Фильтр,Справа=Ложь,НачПозПоиска=Неопределено,НомСтоп=Неопределено,ДлинаТекГруппы=0,НачСледГруппы=0,НомСледГр=0)

//Стр_НайтиЧисл(ВходСтр,НомВхожд=1,Справа=Ложь,ОшибкаНоль=Ложь,ИгнорироватьСимв=Неопределено,ПозЧ=0,ПозС=0)
//Находит и возвращает число с указанным номером вхождения, в т.ч. справа. 
//Не "боится" нецифровых символов до/после числа
//
//ВХОД:
// ВходСтр          - входная строка;
// НомВх            - номер вхождения Числа
// Справа           - если Истина - ищем справа
// ОшибкаНоль       - если Истина - возврашщает 0 при ошибке, иначе - Неопределено;
// ИгнорироватьСимв - набор игнорруемых нач. символов (умолчание - игнорировать все)
//                    "+" - игноририуются любые символы;
//                    "-" - нет игнорируемых символов;
//                    "+"+(игнорируемые имволы)
//                    "-"+(не игнорируемые символы) 
//
//ВЫХОД:
// ПозЧ - позиция начала числа;
// ПозС - позиция начала остаточной строки;
//
Функция Стр_НайтиЧисл(ВходСтр,НомВхожд=1,Справа=Ложь,ОшибкаНоль=Ложь,ИгнорироватьСимв="+",ПозЧ=0,ПозС=0) Экспорт 
	Дл=СтрДлина(ВходСтр); Ош0=?(ОшибкаНоль=Истина,0,Неопределено); ПозЧ=0; ПозС=0; Если Дл=0 тогда Возврат Ош0; КонецЕсли;
	ИС0=ИгнорироватьСимв;
	Зн=Лев(ИС0,1); ИС=Сред(ИС0,2); ИгнТ=Ложь; ИгнП=Ложь; ИгнМ=Ложь; НомВх=?((НомВхожд=0) или (НомВхожд=Неопределено),1,НомВхожд);
	Если ИС="" тогда Если Зн="+" тогда ИгнТ=Истина; ИгнП=Истина; ИгнМ=Истина; КонецЕсли; 
	ИначеЕсли Зн="+" тогда ИгнТ=(Найти(ИС,".")>0); ИгнП=(Найти(ИС,"+")>0); ИгнМ=(Найти(ИС,"-")>0);		
	ИначеЕсли Зн="-" тогда ИгнТ=(Найти(ИС,".")=0); ИгнП=(Найти(ИС,"+")=0); ИгнМ=(Найти(ИС,"-")=0);		
	КонецЕсли;
	ПозС=1; ПозЧ=Дл+1; Ном=0; Ош=Неопределено;
	Для Сч0=1 по 10000 цикл Поз=0; Стр=""; ЕстьЦ=Ложь; ЕстьТ=Ложь; ЕстьЗ=Ложь; 
		Если Справа тогда //___СПРАВА_________________________________
			ПозН=ПозЧ-1;
			Для Сч=-ПозН по -1 Цикл Поз=-Сч; С=Сред(ВходСтр,Поз,1); Т=0;
				Если С="." тогда Т=1; ИначеЕсли Найти("+-",С)>0 тогда Т=2; ИначеЕсли Найти("0123456789",С)>0 тогда Т=3; КонецЕсли;	
				//
				Если (Не ЕстьЦ) и (Т<>3) тогда //все кроме цифры и еще не начат набор цифр
					Если ИС="" тогда Если Зн<>"+" тогда Прервать; Иначе Продолжить; КонецЕсли;
					ИначеЕсли (С=".") тогда Если ИгнТ тогда Продолжить; Иначе Прервать; КонецЕсли; 	
					ИначеЕсли (С="+") тогда Если ИгнП тогда Продолжить; Иначе Прервать; КонецЕсли; 	
					ИначеЕсли (С="-") тогда Если ИгнМ тогда Продолжить; Иначе Прервать; КонецЕсли; 	
					Иначе Н=Найти(ИС,С); Если ((Зн="+") и (Н>0)) или ((Зн="-") и (Н=0)) тогда Продолжить; Иначе Прервать; КонецЕсли;
					КонецЕсли;		
				ИначеЕсли Т=3 тогда ПозС=?(ЕстьЦ,ПозС,Поз+1); ЕстьЦ=Истина; Стр=С+Стр; //цифра	
				ИначеЕсли Т=1 тогда Если ЕстьТ или ЕстьЗ тогда Прервать; Иначе Стр=С+Стр; ЕстьТ=Истина; КонецЕсли; //точка
				ИначеЕсли Т=2 Тогда Если ЕстьЗ тогда Прервать; Иначе Стр=С+Стр; ЕстьЗ=Истина; КонецЕсли; //знак
				Иначе	Прервать;
				КонецЕсли;	
			КонецЦикла;		
			//
			Если (Стр="") или (Стр=".") или (Стр="+") или (Стр="-") тогда ПозЧ=0; ПозС=0; Вых=Ош;
			Иначе ПозЧ=?(Поз<2,0,Поз+1); ПозС=ПозС; Вых=Число(Стр);
			КонецЕсли;		
		Иначе //___СЛЕВА______________________________________________	
			ПозН=ПозС;
			Для Сч=ПозН по Дл цикл С=Сред(ВходСтр,Сч,1); Поз=Сч; Т=0;
				Если С="." тогда Т=1; ИначеЕсли Найти("+-",С)>0 тогда Т=2; ИначеЕсли Найти("0123456789",С)>0 тогда Т=3; КонецЕсли;	
				//
				Если Т=3 тогда ПозЧ=?(ЕстьЦ,ПозЧ,Поз); ЕстьЦ=Истина; Стр=Стр+С; //цифра
				ИначеЕсли Т=1 тогда //точка
					Если ЕстьТ тогда 
						Если ЕстьЦ тогда Прервать; ИначеЕсли ИгнТ тогда Продолжить; Иначе Прервать; КонецЕсли;
					Иначе Стр=Стр+С; ЕстьТ=Истина;	
					КонецЕсли;	
				ИначеЕсли С="+" Тогда Если ЕстьЦ тогда Прервать; КонецЕсли; //знак "+"
				    Стр=СтрЗаменить(Стр,".","");
					Если ЕстьЗ тогда 
						Если ИгнП тогда Стр=С; ЕстьТ=Ложь; Продолжить; Иначе Прервать; КонецЕсли;
					Иначе Стр=Стр+С; ЕстьЗ=Истина;	
					КонецЕсли;	
				ИначеЕсли С="-" Тогда Если ЕстьЦ тогда Прервать; КонецЕсли; //знак "-"
				    Стр=СтрЗаменить(Стр,".","");
					Если ЕстьЗ тогда 
						Если ИгнМ тогда Стр=С; ЕстьТ=Ложь; Продолжить; Иначе Прервать; КонецЕсли;
					Иначе Стр=Стр+С; ЕстьЗ=Истина;	
					КонецЕсли;	
				ИначеЕсли ЕстьЦ тогда //все, кроме точки,знака или цифры и начат набор цифр
					Прервать;
				ИначеЕсли ИС="" тогда //все, кроме точки,знака или цифры и ИС=""
					Если Зн<>"+" тогда Прервать; Иначе ЕстьТ=Ложь; ЕстьЗ=Ложь; ЕстьЦ=Ложь; Стр=""; Продолжить; КонецЕсли;
				Иначе //все, кроме точки,знака или цифры и есть строка ИС	
					Н=Найти(ИС,С); ЕстьТ=Ложь; ЕстьЗ=Ложь; Стр="";
					Если ((Зн="+") и (Н>0)) или ((Зн="-") и (Н=0)) тогда Продолжить; Иначе Прервать; КонецЕсли;
				КонецЕсли;	
			КонецЦикла;	
			//
			Если (Стр="") или (Стр=".") или (Стр="+") или (Стр="-") тогда ПозЧ=0; ПозС=0;  Вых=Ош;
			Иначе ПозС=?(Поз=Дл,0,Поз); С1=Лев(Стр,1); С2=Сред(Стр,2,1); 
				Если Найти("+-.",С1)>0 тогда ПозЧ=ПозЧ-1; КонецЕсли;
				Если С2="." тогда ПозЧ=ПозЧ-1; КонецЕсли;
				Если Сред(Стр,СтрДлина(Стр),1)="." тогда ПозС=ПозС-1; КонецЕсли;
				Вых=Число(Стр);
			КонецЕсли;	
		КонецЕсли;	
		Если Вых=Неопределено тогда Прервать; КонецЕсли;	
		Ном=Ном+1; Если Ном=НомВх тогда Прервать; КонецЕсли;	
	КонецЦикла; 	
	//
	Возврат ?(Вых=Неопределено,Ош0,Вых);
КонецФункции //Стр_НайтиЧисл(ВходСтр,НомВхожд=1,Справа=Ложь,ОшибкаНоль=Ложь,ИгнорироватьСимв=Неопределено,ПозЧ=0,ПозС=0)

//&НаСервереБезКонтекста
//Функция Стр_Интерпретировать(ВхПарам,ДляФильтра=Истина,Сортировка=Ложь,ПодавлятьПервыйПлюсМинус=Ложь)
//Создает массив из строкового представления (ВходПарам).
//
//_________________________________________________
//Синтаксис входного строкового представления (ВходПарам).
//
//Общий фильтр (или комплексный разделитель)  может 
//состоять из нескольких уровней фильтра (или разделителя),
//разделенных знаком "/" или из Массива с уровнями .
//В фильтре каждого уровня могут присутствовать:
//	- Спец.Коды группировок символов; 
//	- отдельные подстроки символов в кавычках; 
//	- коды символов через "," в простых скобках. 
//	  (Поддерживается конструкция типа(123:2000) - 
//	  вхождение всех символов с кодами от 123 до 2000).
//  - Конструкция типа "{...}", где внутри фигурных
//     скобок может быть любое выражение, возвращающее
//     Строку.
//
//Все это может быть соединено знаками "+" или "-", 
//что для фильтра означает - проверка на вхождение или невхождение. 
//(отсутствие знака - значит "+"). Пробелы игнорируются.
//Спец.Коды группировок:
//  г - гласные нижн.рег.;     Г - Гласные верхн.рег.;
//  с - согл.нижн.рег.;        С - Согл.верхн.рег.;
//  р - русские нижн.рег;      Р - Русские верхн.рег.;
//  g - гласные лат.нижн.рег.; G - Гласные лат.верхн.рег.;
//  s - согл.лат.нижн.рег.;    S - Согл.лат.верхн.рег.;
//  l - лат.нижн.рег;          L - лат.верхн.рег.;
//  Ц или ц - Цифры;           З или з - "клавиатурные" Знаки; 
//  П или п - знаки Препинания; 
////
//ЗАМЕЧАНИЕ: "кавычки" - как отдельный знак - может быть 
//  передан только через код символа, т.е. вот так: (34)
//ЗАМЕЧАНИЕ Начальные знаки "+" или "-" устанавливаются 
//  только для Фильтра (ДляФильтра=Истина). для режима
//  Разделителя , иначе
//  ыражение со знаком "-" просто игнорируется. 
//ЗАМЕЧАНИЕ: Для Фильтра автоматически поддерживается 
//  уникальность группирующих наборов символов -
//  Символы последующего уровня не входят в предыдущий. 
//  Символы каждого уровня также уникальны.
//
//Если Сортировка=Истина, выходные строки Фильтра сортируются
//Согласно Уникодам символов (только для режима Фильтра!);
//
//Если ПодавлятьПервыйПлюсМинус=Истина - в строках фильтра
//не устанавливаются начальные "+" или "-" 
//(только для режима Фильтра!) 
Функция Стр_Интерпретировать(ВхПарам,ДляФильтра=Истина,Сортировка=Ложь,ПодавлятьПервыйПлюсМинус=Ложь) Экспорт
	//
	//Если на входе строка с разделителем "/" - создаем массив с подстроками- уровнями 
	МА=Новый Массив; Кав=""""; Вход=ВхПарам;
	Если ТипЗнч(Вход)=Тип("Массив") тогда МА=Вход;
	Иначе Нач=0; Пар1=СокрЛП(Вход); Дл=СтрДлина(Пар1); СтрФ=""; Г0=0;	З="";		
		Для Сч=1 по Дл Цикл С=Сред(Пар1,Сч,1);
			Если (С="/") и Нач=0 тогда Ма.Добавить(СтрФ); СтрФ=""; //Конец Фрагмента
			Иначе СтрФ=СтрФ+С; 
				Если (С=Кав) и (Нач<>1) и (Нач<>3) тогда Нач=1; //Открытие кавычек
				ИначеЕсли (С="{") и (Нач<>3) тогда Нач=3; //открытие скобок макроса	
				ИначеЕсли (С=Кав) и (Нач=1) тогда Нач=0;  //Закрытие кавычек
				ИначеЕсли (С="}") и (Нач=3) тогда Нач=0;  //Закрытие скобок макроса	
				КонецЕсли;					
			КонецЕсли;
		КонецЦикла;			
		Если СтрФ<>"" тогда Ма.Добавить(СтрФ); КонецЕсли;  	
	КонецЕсли;
	//
	//__________________________________________________________________________________________
	//Вход, Спец.Коды:
	//г-гласные нижн.рег.; Г-Гласные верхн.рег.; с-согл.нижн.рег.; С-Согл.верхн.рег.; р-русские нижн.рег; Р-Русские верхн.рег.
	//g-гласные лат.нижн.рег.; G-Гласные лат.верхн.рег.; s-согл.лат.нижн.рег.; S-Согл.лат.верхн.рег.; l-лат.нижн.рег; L-лат.верхн.рег.
	//Ц или N - Цифры; З-"клавиатурные" Знаки; П - знаки Препинания.
	//Подготовка строк
	РВ="ЁАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ";	РН="абвгдежзийклмнопрстуфхцчшщъыьэюяё";  //Русские верхний и нижний регистры
	ГН="аеиоуыэюяё"; СН="бвгджзйклмнпрстфхццчщъь"; ГВ=ВРег(ГН); СВ=Врег(СН);         //Русские гласные и согласные
	LV="ABCDEFGHIJKLMNOPQRSTUVWXYZ"; LN="abcdefghijklmnopqrstuvwxyz";                //Латинские верхний и нижний регистры
	GN="aeiou"; SN="bcdfghjklmnpqrstvwxyz"; GV=ВРег(GN); SV=ВРег(SN);                //Латинские  гласные и согласные
	Ц="0123456789"; З="№ `~,.:;-+=?!\/<>()[]{}@#$%^&*""|"; П=",.:;- ?!"; //Цифры,"клавиатурные" Знаки, знаки Препинаниня
	//
	Ст=Новый Соответствие; 
	Ст.Вставить("г",ГН); Ст.Вставить("Г",ГВ); Ст.Вставить("с",СН); Ст.Вставить("С",СВ); //гласные и согласные Русские
	Ст.Вставить("g",GN); Ст.Вставить("G",GV); Ст.Вставить("s",SN); Ст.Вставить("S",SV); //гласные и согласные Латинские 
	Ст.Вставить("р",РН); Ст.Вставить("Р",РВ); Ст.Вставить("l",LN); Ст.Вставить("L",LV); //Русские и латинские
	Ст.Вставить("ц",Ц);  Ст.Вставить("Ц",Ц);  Ст.Вставить("з",З);  Ст.Вставить("З",З);  //Цифры и Знаки (клавиатурные)
	Ст.Вставить("п",П);  Ст.Вставить("П",П);                                            //знаки Препинания
	//
	//Создаем Массив с фильтрами-строками ("расшифрованными"):
	Фи=Новый Массив; Кг=МА.Количество(); КолГр=Кг;
	Для Г=1 по Кг цикл СтрГ=СокрЛП(МА[Г-1]); Дл=СтрДлина(СтрГ); З=""; Стр1=""; Стр2=""; Нач=0; Стр3=""; Стр4=""; //цикл по Фильтрам
		Если Лев(СтрГ,1)="~" тогда З=Сред(СтрГ,2,1); Стр1=Сред(СтрГ,3); Фи.Добавить(З+Стр1); Продолжить; КонецЕсли; 
		//			
		Для Сч=1 по Дл цикл С=Сред(СтрГ,Сч,1); //Цикл по строке Фильтра
			Если (Нач<>1) и (Нач<>3) тогда //не знаки в кавычках и не макрос
				Если С=" " тогда Продолжить; КонецЕсли;                    //пропускаем пробелы
				Если (С="+") или (С="-") тогда З=С; продолжить; КонецЕсли; //Устанавливаем знак
			КонецЕсли;
			//
			Если (С=Кав) и (Нач=0) тогда Нач=1; З=?(З="","+",З); Продолжить;               //Начало группы символов в кавычках
			ИначеЕсли (С=Кав) и (Нач=1) тогда Нач=0; З=""; Продолжить;                     //Закрытие кавычек
			ИначеЕсли (С="(") и (Нач=0) тогда Нач=2; Стр3=""; З=?(З="","+",З); Продолжить; //Начало группы кодов в скобках
			ИначеЕсли (С="{") и (Нач=0) тогда Нач=3; З=?(З="","+",З); Стр4=""; Продолжить; //начало макроса в скобках 
			ИначеЕсли (С="}") и (Нач=3) тогда                                              //завершение набора макроса 
				Если Стр4<>"" тогда ССС=""; //пытаемся выполнить макрос
					Попытка Выполнить("ССС="+Стр4); Если З="-" тогда Стр2=Стр2+ССС; иначе Стр1=Стр1+ССС; КонецЕсли;  
					Исключение Сообщить("Ошибка выполнения.  Выполнить(ссс="+Стр4+")"); 
					КонецПопытки;
				КонецЕсли;		
				Нач=0; Стр4=""; З=""; Продолжить;
			КонецЕсли;
			//
			Если Нач=1 тогда Если З="-" тогда Стр2=Стр2+С иначе Стр1=Стр1+С; КонецЕсли; //работа в кавычках
			ИначеЕсли Нач=2 тогда                                                       //работа с кодами в скобках
				Если (С=",") или (С=")") тогда нн=Найти(Стр3,":"); //раскрываем интервал кодов 
					Если нн=0 тогда Си=Символ(0+Стр3); 
					Иначе Си=""; Код1=0+Лев(Стр3,нн-1); Код2=0+Сред(Стр3,НН+1); Для счК=Код1 по Код2 Цикл Си=Си+Символ(СчК); КонецЦикла; 
					КонецЕсли;	
					Если З="-" тогда Стр2=Стр2+Си; Иначе Стр1=Стр1+Си; КонецЕсли; 
					Стр3=""; Если С=")" тогда Нач=0; З=""; Продолжить; КонецЕсли;
				Иначе Стр3=Стр3+С;	
				КонецЕсли;	
			ИначеЕсли Нач=3 тогда Стр4=Стр4+С;                                         //дописываем символ к макросу	
			Иначе СтрС=Ст.Получить(С);                                                 //расшифровка спец.кодов
				Если З="-" тогда Стр2=Стр2+СтрС; Иначе Стр1=Стр1+СтрС; КонецЕсли; З="";
			КонецЕсли;				
		КонецЦикла;	//по строке Фильтра	
		//
		Если ДляФильтра тогда //приводим к одной строке с первым знаком "+" или "-"
			//Оптимизация фильтра группировки
			Дл1=СтрДлина(Стр1); Дл2=СтрДлина(Стр2); 
			Стр=Стр1; Стр1=""; Для Сч=1 по Дл1 цикл С=Сред(Стр,Сч,1); Если Найти(Стр1,С)=0 тогда Стр1=Стр1+С; КонецЕсли; КонецЦикла;
			Стр=Стр2; Стр2=""; Для Сч=1 по Дл2 цикл С=Сред(Стр,Сч,1); Если Найти(Стр2,С)=0 тогда Стр2=Стр2+С; КонецЕсли; КонецЦикла;
			Если (Дл1<>0) и (Дл2<>0) тогда 
				Для сч=1 по Дл2 цикл
					Н=Найти(Стр1,Сред(Стр2,Сч,1)); Если Н>0 тогда Стр1=Лев(Стр1,Н-1)+Сред(Стр1,Н+1); КонецЕсли;				
				КонецЦикла;	
				Стр2=""; 	
			КонецЕсли;	
			СтрВых=?(Стр2="","+","-")+?(Стр2="",Стр1,Стр2);
			Если Сортировка тогда СтрВых=Лев(СтрВых,1)+Стр_УниСорт(Сред(СтрВых,2)); КонецЕсли;
			Если ПодавлятьПервыйПлюсМинус тогда СтрВых=Сред(СтрВых,2) КонецЕсли;
			Фи.Добавить(СтрВых);		
		Иначе //учитываем только "положительную" Стр1, Стр2 игнорируется.
			СтрВых=Стр1; //Если ПодавлятьПервыйПлюс и (Лев(СтрВых,1)="+") тогда СтрВых=Сред(СтрВых,2) КонецЕсли;
			Фи.Добавить(СтрВых); 	
		КонецЕсли;		
	КонецЦикла;	//по уровням	
	Возврат Фи;	
КонецФункции //Стр_Раскрыть(ВходСтр,ДляФильтра=Истина)	

//    1.2. ПРОИЗВОДНЫЕ МЕТОДЫ (13 функций).
//    Собственно, это применения обобщенных методов-алгоритмов
//    с определенными параметрами (см. часть 2).

//Стр_Число(ВходСтр,Справа=Ложь,ОшибкаНоль=Ложь,ПозЧ=0,ПозС=0)
//Возвращает число, в т.ч. справа. Не "боится" нецифровых символов после числа
//Игнорируются начальные символы, такие же как для Сокр..().
//
//ВХОД:
// ВходСтр    - входная строка;
// ОшибкаНоль - если Истина - возврашщает 0 при ошибке, иначе - Неопределено;
// Справа     - если Истина - число справа
//
//ВЫХОД:
// ПозЧ - позиция начала числа;
// ПозС - позиция остаточной строки (начало или конец, если Справа);
//
Функция Стр_Число(ВходСтр,Справа=Ложь,ОшибкаНоль=Ложь,ПозЧ=0,ПозС=0) Экспорт 
	ИгнСимв="+ "+Символы.ВК+Символы.ВТаб+Символы.НПП+Символы.ПС+Символы.ПФ+Символы.Таб; ПозЧ=0; ПозС=0;
	Возврат Стр_НайтиЧисл(ВходСтр,1,Справа,ОшибкаНоль,ИгнСимв,ПозЧ,ПозС);	
КонецФункции //Стр_Число(ВходСтр,Справа=Ложь,ОшибкаНоль=Ложь,ПозЧ=0,ПозС=0)

//Функция Стр_Найти(ВходСтр,Разделитель,НомВхождения=1,Справа=Ложь,БезРегистра=Ложь,ДопВыход)
//Возвращает начальную позицию СтрПоиска с номером вхождения (НомВхождения).
//ВХОД
//  ВходСтр      - входная строка;
//  СтрПоиска    - что, собственно и ищем;
//  НомВхождения - номер вхождения искомой СтрПоиска;
//  Справа       - если Истина - поиск справа;
//  БезРегистра  - если Истина - поиск без учета регистра символов;
//ВЫХОД
//  ПозСлед      - нач. позиция следующего поиска; 
//  МаксНом      - максимальный полученный номер вхождения; 
Функция Стр_Найти(ВходСтр,СтрПоиска,НомВхождения=1,Справа=Ложь,БезРегистра=Ложь,ПозСлед=0,МаксНом) Экспорт
		Возврат Стр_Вхождение(ВходСтр,СтрПоиска,Неопределено,НомВхождения,,Справа,БезРегистра,ПозСлед,МаксНом);
КонецФункции //	

//Функция Стр_Заменить(ВходСтр,СтрПоиска="",СтрЗамены="",НачНомВхождения=1,КонНомВхождения=10000000,Справа=Ложь,БезРегистра=Ложь)
//Возвращает строку. 
//Аналог СтрЗаменить(); Но:
//в исходной строке (ВходСтрока) заменяет разделители (СтрПоиска) 
//на (СтрЗамены) начиная с (НачНомВхождения) до (КонНомерВхождения);
//поиск-замена возможны как слева, так и справа (Справа=Истина); 
//возможен поиск без учета регистра (Безрегистра=Истина).
Функция Стр_Заменить(ВходСтр,СтрПоиска="",СтрЗамены="",НачНомВхождения=1,КонНомВхождения=10000000,Справа=Ложь,БезРегистра=Ложь) Экспорт
	Возврат Стр_Вхождение(ВходСтр,СтрПоиска,СтрЗамены,НачНомВхождения,КонНомВхождения,Справа,БезРегистра);
КонецФункции //Функция Стр_Заменить_(ВходСтр,СтрПоиска="",СтрЗамены="",НачНомВхождения=1,КонНомВхождения=10000000,Справа=Ложь,БезРегистра=Ложь)

//Функция Стр_Кусок(ВходСтр,Разделитель="",НачНомВхождения=1,КонНомВхождения=10000000,Справа=Ложь,БезРегистра=Ложь)
//Возвращает строку - "кусок" исходной строки (ВходСтр) между 
//(НачНомВхождения) и (КонНомВхождения) разделителя (Разделитель); 
//поиск возможен как слева, так и справа (если Справа=Истина); 
//возможен поиск без учета регистра (если Безрегистра=Истина).
Функция Стр_Кусок(ВходСтр,Разделитель="",НачНомВхождения=1,КонНомВхождения=10000000,Справа=Ложь,БезРегистра=Ложь) Экспорт
	Возврат Стр_Фрагменты(ВходСтр,Разделитель,Неопределено,НачНомВхождения,КонНомВхождения,Справа,БезРегистра,"С");
КонецФункции //Стр_Заменить(ВходСтр,СтрПоиска="",СтрЗамены="",НачНомВхождения=1,КонНомВхождения=10000000,Слева=Истина)	

//Функция Стр_ЗаменитьКусок(ВходСтр,Разделитель="",СтрВставки="",НачНомВхождения=1,КонНомВхождения=10000000,Справа=Ложь,БезРегистра=Ложь)
//Возвращает строку.
//В исходной строке (ВходСтр) "кусок" между (НачНомВхождения) и
//(КонНомВхождения) разделителя (Разделитель) заменяется на (СтрЗамены).
//Поиск возможен как слева, так и справа (Справа=Истина); 
//Возможен поиск без учета регистра (Безрегистра=Истина).
Функция Стр_ЗаменитьКусок(ВходСтр,Разделитель="",СтрЗамены="",НачНомВхождения=1,КонНомВхождения=10000000,Справа=Ложь,БезРегистра=Ложь) Экспорт
	Возврат Стр_Фрагменты(ВходСтр,Разделитель,СтрЗамены,НачНомВхождения,КонНомВхождения,Справа,БезРегистра,"С")
КонецФункции //Стр_ЗаменитьКусок(ВходСтр,Разделитель="",СтрВставки="",НачНомВхождения=1,КонНомВхождения=10000000,Справа=Ложь,БезРегистра=Ложь,Масс="")

//Функция Стр_ВМассив(ВходСтр,Разделитель="",НачНомВхождения=1,КонНомВхождения=10000000,Справа=Ложь,БезРегистра=Ложь)
//Возвращает массив с фрагментами строки
//между (НачНомВхождения) и (КонНомВхождения) разделителя (Разделитель);
//поиск разделителя возможен и справа (если Справа=Истина); 
//возможен поиск без учета регистра (если Безрегистра=Истина).
Функция Стр_ВМассив(ВходСтр,Разделитель="",НачНомВхождения=1,КонНомВхождения=10000000,Справа=Ложь,БезРегистра=Ложь) Экспорт
	Возврат Стр_Фрагменты(ВходСтр,Разделитель,Неопределено,НачНомВхождения,КонНомВхождения,Справа,БезРегистра,"М");
КонецФункции //Стр_ЗаменитьКусок(ВходСтр,Разделитель="",СтрВставки="",НачНомВхождения=1,КонНомВхождения=10000000,Справа=Ложь,БезРегистра=Ложь,Масс="")

//Функция Стр_ПеренестиПоСлогам(ВходСтр,Длины)
//Возвращает массив с подстроками, созданных по 
//правилам "Жесткого" переноса (по слогам, с дефисом).
//
//ВХОД:
//  ВходСтр     - входная строка;
//  Длины       - Массив с длинами Подстрок или Число - длина подстрок;
//  БезОстатка  - до конца строки; подстроки с номерами большими
//                количества длин в массиве (Длины) получают длину из
//                последнего элемента этого массива; 
//  Разделители - строка из символов- разделителей слов.
//ВЫХОД:
//  ОстатокСтроки - (может быть не пустым, если БезОстатка=Ложь)
Функция Стр_ПеренестиПоСлогам(ВходСтр,Длины,БезОстатка=Ложь,Разделители=". ,:-+=<>?!;",ОстатокСтроки="") Экспорт
	Возврат Стр_Разбить(ВходСтр,Длины,"Ж",БезОстатка=Ложь,Разделители,ОстатокСтроки);	
КонецФункции //

//Функция Стр_ПеренестиПоСловам(ВходСтр,Длины)
//Возвращает массив с подстроками, созданных по 
//правилам "Мягкого" переноса (по границам слов).
//
//ВХОД:
//  ВходСтр     - входная строка;
//  Длины       - Массив с длинами Подстрок или Число - длина подстрок;
//  БезОстатка  - до конца строки; подстроки с номерами большими
//                количества длин в массиве (Длины) получают длину из
//                последнего элемента этого массива; 
//  Разделители - строка из символов- разделителей слов.
//ВЫХОД:
//  ОстатокСтроки - (может быть не пустым, если БезОстатка=Ложь)
Функция Стр_ПеренестиПоСловам(ВходСтр,Длины,БезОстатка=Ложь,Разделители=". ,:-+=<>?!;",ОстатокСтроки="") Экспорт
	Возврат Стр_Разбить(ВходСтр,Длины,"М",БезОстатка=Ложь,Разделители,ОстатокСтроки);	
КонецФункции //

//Функция Стр_Разрезать(ВходСтр,Длины)
//Возвращает массив с подстроками  созданных 
//путём "разрезания" исходной строки 
//по указанным длинам (Длины).
//
//ВХОД:
//  ВходСтр     - входная строка;
//  Длины       - Массив с длинами Подстрок или Число - длина подстрок;
//  БезОстатка  - до конца строки; подстроки с номерами большими
//                количества длин в массиве (Длины) получают длину из
//                последнего элемента этого массива; 
//  Разделители - строка из символов- разделителей слов.
//ВЫХОД:
//  ОстатокСтроки - (может быть не пустым, если БезОстатка=Ложь)
Функция Стр_Разрезать(ВходСтр,Длины,БезОстатка=Ложь,ОстатокСтроки="")
	Возврат Стр_Разбить(ВходСтр,Длины,"Р",БезОстатка=Ложь,,ОстатокСтроки);	
КонецФункции //

//Функция Стр_СокрЛ(ВходСтр,СокрСимв=Неопределено,СтрЗамены="")
//Находит начальную левую группу из символов
//входящих в (СокрСимв) и заменяет её на (СтрЗамены)
//Впереди (СокрСимв) знак "+"(вхождение) или "-"(невхождение).
//По умолчанию (СокрСимв) - те же символы, что
// и для встроенных методов СокрЛ() и Сокр(П)(добавляем впереди "+").
Функция Стр_СокрЛ(ВходСтр,СокрСимв=Неопределено,СтрЗамены="")
	Возврат Стр_Сокр("Л",ВходСтр,0,СокрСимв,СтрЗамены);
КонецФункции //	

//Функция Стр_СокрП(ВходСтр,СокрСимв=Неопределено,СтрЗамены="")
//Находит начальную правую группу из символов
//входящих в (СокрСимв) и заменяет её на (СтрЗамены).
//Впереди (СокрСимв) знак "+"(вхождение) или "-"(невхождение).
//По умолчанию (СокрСимв) - те же символы, что
// и для встроенных методов СокрЛ() и Сокр(П)(добавляем впереди "+").
Функция Стр_СокрП(ВходСтр,СокрСимв=Неопределено,СтрЗамены="")
	Возврат Стр_Сокр("П",ВходСтр,0,,,СокрСимв,СтрЗамены);
КонецФункции //	

//Функция Стр_СокрС(ВходСтр,СокрСимв=Неопределено,СтрЗамены=" ")
//Находит в строке группы из символов
//входящих в (СокрСимв) и заменяет их на (СтрЗамены).
//Впереди (СокрСимв) знак "+"(вхождение) или "-"(невхождение).
//По умолчанию (СокрСимв) - те же символы, что
// и для встроенных методов СокрЛ() и СокрП()(добавляем впереди "+").
Функция Стр_СокрС(ВходСтр,СокрСимв=Неопределено,СтрЗамены=" ")
	Возврат Стр_Сокр("С",ВходСтр,0,,,,,СокрСимв,СтрЗамены);
КонецФункции //	

//Функция Стр_Расширить(ВходСтр,Длина=0,СокрСимв=Неопределено,СтрЗамены=" ")
//Находит в строкt группы из символов
//входящих в (СокрСимв) и заменяет их на  
//строки (СтрЗамены) в таком количестве, чтобы
//достичь заданной полной длины строки (Длина).
//Впереди у (сокрСимв) знfк "+"(вхождение) или "-"(невхождение).
//По умолчанию (СокрСимв) - те же символы, что
// и для встроенных методов СокрЛ() и Сокр(П)(добоаляем впереди "+").
Функция Стр_Расширить(ВходСтр,Длина=0,СокрСимв=Неопределено,СтрЗамены=" ") Экспорт
	Возврат Стр_Сокр("С",ВходСтр,Длина,,,,,СокрСимв,СтрЗамены);
КонецФункции //	


//    1.3. ДЕТАЛЬНЫЕ МЕТОДЫ (3 функций).
//    "Препарирование" строки и передача в ТЗ с детальной информацией.

//Функция Стр_ВТаблГр(Вход,Фильтр="",РаскрыватьФильтр=Ложь,ВыводитьГруппы=Ложь,Частотность=Ложь,ДопВыход="")
//Возвращает ТЗ с детальной информацие о фрагментах строки(группах)
//полученных в результате применения многоуровнего группирующего фильтра (Фильтр)
//Фильтр, в общем случае, представляет собой массив,
//каждый элемент которого (уровень) есть набор символов с знаком 
//"+"(вхождение) или "-"(не вхождение)в начале набора.
//Возможно строковое задание фильтра - синтаксис такого 
//задания  описан в методе "Стр_Интерпретировать()"
//В случае,если РаскрыватьФилтр=Истина, происходит обращение
//как раз к этому методу.
//
//Колонки возвращаемого ТЗ Статистики:
//  "КГ" - Общ. количество групп символо для данного уровня фильтра
//  "КС" - общ.кол.символов Для данного уровня фильтра
//  "Ур" - Уровень, совпадает с индексо строки ТЗ (0 уровень не прошедшие фильтр)
//  "Ч"  - ТЗ частот (вычиляется,если Частотность=Истина
//
//В ДопВыход попадает ТЗ Групп С колонками:
//  "Фр"  - Фрагмент строки
//  "Ур"  - Уровень
//  "КГ"  - Количество групп (всегда =1,нужна для свертки)
//  "Поз" - начальная позиция фрагмента в строке
//  "КС"  - Количество символов в фрагменте (длина)
//
//  ВыводитьГруппы - если Истина -возвращает ТЗ Групп, иначе 
//              ТЗ Статистики (см. выше) 
//  Частотность - Дополнительно вычеслется частота повторени символов.
//
Функция Стр_ВТаблГр(Вход,Фильтр="",РаскрыватьФильтр=Ложь,ВыводитьГруппы=Ложь,Частотность=Ложь,ДопВыход="") Экспорт
		Выход=Вход; Вх=Вход;
		Если РаскрыватьФильтр тогда Фи=Стр_Интерпретировать(Фильтр);
		ИначеЕсли ТипЗнч(Фильтр)<>Тип("Массив") тогда Фи=Новый Массив; Фи.Добавить(Фильтр);
		Иначе Фи=Фильтр;	
		КонецЕсли;
		Кг=Фи.Количество();
		//Создание Групп (применение Группировок):
		Вых=Новый ТаблицаЗначений; Кол=Вых.Колонки; 
		Кол.Добавить("КГ",,"Колич. Групп"); Кол.Добавить("КС",,"Колич. Симв."); Кол.Добавить("Ур",,"Уровень"); Вых.Колонки.Добавить("Ч",,"Частотность");  
		Для сч=0 по Кг цикл С=Вых.Добавить(); С.Ур=Сч;  КонецЦикла; Вых.ЗаполнитьЗначения(0,"КГ,КС");
		ФлЧ=?(Частотность,1,0); 
		//
		ДопВ=Новый ТаблицаЗначений; Кол1=ДопВ.Колонки; 
		Кол1.Добавить("Фр",,"Фрагмент"); Кол1.Добавить("Ур",,"Уровень"); Кол1.Добавить("КГ",,"Кол.Групп"); Кол1.Добавить("КС",,"Кол.Символов"); Кол1.Добавить("П",,"Позиция");
		//
		Если Частотность тогда ТЗ0=Новый ТаблицаЗначений; Кол=ТЗ0.Колонки; Кол.Добавить("С"); 
			Кол.Добавить("К",новый ОписаниеТипов("Число",Новый КвалификаторыЧисла(10,0))); 
		КонецЕсли;
		//
		ДлВх=СтрДлина(Вх); Г0=0; СтрГ=""; СтрВых=""; Поз=1;
		//
		Для сч=1 по ДлВх цикл С=Сред(Вх,Сч,1); Г=0; Есть=0;
			//
			//Количества символов по группировкам 
			Для каждого Э из Фи цикл Г=Г+1;	Фл=Лев(Э,1); Пр=Сред(Э,2);	Н=Найти(Пр,С);	
				Если ((Н>0) и (Фл="+")) или ((Н=0) и (Фл="-")) тогда Есть=Г; Вых[Г].КС=Вых[Г].КС+1; 
					Если Частотность тогда Т_З=Вых[Г].Ч; //Посимвольная статистика по текущей группировке
						Если ТипЗнч(Т_З)<>Тип("ТаблицаЗначений") тогда Т_З=ТЗ0.Скопировать(); Вых[Г].Ч=Т_З; КонецЕсли;
						СтрТЗ_=Т_З.Найти(С,"С"); Если СтрТЗ_=Неопределено тогда СтрТЗ_=Вых[Г].Ч.Добавить(); СтрТЗ_.С=С; КонецЕсли;
						СтрТЗ_.К=СтрТЗ_.К+1;
					КонецЕсли;		
					Если Сч=1 тогда Г0=Г; конецЕсли; Прервать;  
				КонецЕсли;
			КонецЦикла;				
			Если Есть=0 тогда Вых[0].КС=Вых[0].КС+1; 
				Если Частотность тогда Т_З0=Вых[0].Ч; //Посимвольная статистика символов,не вошедших в группировки
					Если ТипЗнч(Т_З0)<>Тип("ТаблицаЗначений") тогда Т_З0=ТЗ0.Скопировать(); Вых[0].Ч=Т_З0; КонецЕсли;
					СтрТЗ_0=Т_З0.Найти(С,"С"); Если СтрТЗ_0=Неопределено тогда СтрТЗ_0=Вых[0].Ч.Добавить(); СтрТЗ_0.С=С; КонецЕсли;
					СтрТЗ_0.К=СтрТЗ_0.К+1; 
				КонецЕсли;		
			КонецЕсли;
			//
			//Количества группировок и запись группы 
			Если (Г0<>Есть) и (Сч>1) тогда Вых[Г0].КГ=Вых[Г0].КГ+1;
				Д=ДопВ.Добавить(); Д.Ур=Г0; Д.Фр=СтрГ; Д.КГ=1; Д.КС=СтрДлина(СтрГ); Д.П=Поз; СтрГ=""; Г0=Есть; Поз=Поз+Д.КС;
			КонецЕсли;					
			СтрГ=СтрГ+С;
		КонецЦикла;
		Вых[Г0].КГ=Вых[Г0].КГ+1; Д=ДопВ.Добавить(); Д.Ур=Г0; Д.Фр=СтрГ; Д.КГ=1; Д.КС=СтрДлина(СтрГ); Д.П=Поз; 		
		Если      ВыводитьГруппы тогда Выход=ДопВ; ДопВыход=Вых; 
		Иначе	Выход=Вых; ДопВыход=ДопВ;
		КонецЕсли;	
		//
		Возврат Выход;
КонецФункции //Стр_Группировки()	

//Функция Стр_ВТаблВх(Вход,Разделители,РаскрыватьРазделители=Ложь,БезРегистра=Ложь,ДопВыход="")
//Возвращает ТЗ с детальной информаций - 
//разложение на систему вложенных разделителей (Разделители)
//Структуру ТЗ см. в Стр_Фрагменты()(только значение Ур, конечно 
//равно уровню вложения текущего разделителя)
//
//ВХОД
//  Вход   - входная строка;
//  Разделители - массив сразделителями. Возможно строкоое задание
//                системы разделителй; в этом случае производитья
//                "расшифровка"  функцией Стр_Интерпретировать().
//                Для этого необходимо (РаскрыватьРазделители)=Истина.
//                Подробно о синтаксисе - см. Стр_Интерпретироавать(). 
//  БезРегистра - если истина - поиск без учета регистра
//  ДопВыход    - не используется.
Функция Стр_ВТаблВх(Вход,Разделители,РаскрыватьРазделители=Ложь,БезРегистра=Ложь,ДопВыход="") Экспорт
    Таб0=Новый ТаблицаЗначений; КолТЗ=Таб0.Колонки; 
	КолТЗ.Добавить("Фр",,"Фрагмент"); КолТЗ.Добавить("Ур",,"Уровень"); КолТЗ.Добавить("КГ",,"Кол.Групп"); 
	КолТЗ.Добавить("Поз",,"Позиция"); КолТЗ.Добавить("КС",,"Кол.Символов"); 
	ТекУр=0; Таб=Стр_Фрагменты(Вход,,Неопределено,0,10000000,Ложь,БезРегистра,"Т",ТекУр);	
	//
	Если Вход="" тогда Возврат Таб0; КонецЕсли;	
	Если РаскрыватьРазделители тогда Ра=Стр_Интерпретировать(Разделители,Ложь);
	ИначеЕсли ТипЗнч(Разделители)<>Тип("Массив") тогда Ра=Новый Массив; Ра.Добавить(Разделители);
	Иначе Ра=Разделители;	
	КонецЕсли;
	//
	Для каждого ТекР из Ра Цикл ТекУр=ТекУр+1; ТЗ=Таб0.Скопировать(); //по вложенным разделителям
		Для каждого СтрТ из Таб цикл //по строкам Таб
			Если СтрТ.Ур>0 тогда СтрТЗ=Тз.Добавить(); 
				СтрТЗ.Фр=СтрТ.Фр; СтрТЗ.Ур=СтрТ.Ур; СтрТЗ.КГ=СтрТ.КГ; СтрТЗ.КС=СтрТ.КС; СтрТЗ.Поз=СтрТ.Поз; 
			Иначе Поз=Стр_Число(СтрТ.Поз); 
				Таб1=Стр_Фрагменты(СтрТ.Фр,ТекР,Неопределено,0,10000000,Ложь,БезРегистра,"Т",ТекУр);	
				Для каждого СтрТ1 из Таб1 цикл СтрТЗ=Тз.Добавить(); 
					СтрТЗ.Фр=СтрТ1.Фр; СтрТЗ.Ур=СтрТ1.Ур; СтрТЗ.КГ=СтрТ1.КГ; СтрТЗ.КС=СтрТ1.КС; СтрТЗ.Поз=Стр_Число(СтрТ1.Поз)+Поз-1; 
				КонецЦикла;			
			КонецЕсли;		
		КонецЦикла; //По строкам Таб;
		Таб=ТЗ.Скопировать();	
	КонецЦикла; //Пов вложенным разделителям
	Возврат Таб;	
КонецФункции //Стр_ВТаблВх(Вход,Разделители,РаскрыватьРазделители=Ложь,БезРегистра=Ложь,ДопВыход="")	

//Функция Стр_вТаблЧисел(ВходСтр,НачНомВх=1,КонНомВх=10000000,Справа=Ложь,ОшибкаНоль=Ложь,ИгнорироватьСимв="+")
//Строка с числами переноситься в ТЗ
//с колонками:
//   "Фр"  - Число или фрагмент строки между числами;
//   "Ур"  - "Уровень" чмсла/фрагмента (для фрагмента - 0, для числа = 1);
//   "КГ"  - количество групп (1, нужна для свертки);
//   "Поз" - позиция начала Числа/фрагмента в исходной строке
//   "КС"  - количество символов в Числе/фрагменте (длина);
//(НачНомВх) и (КонНомВх) -  нач. и кон номера поиска.
Функция Стр_вТаблЧисел(ВходСтр,НачНомВх=1,КонНомВх=10000000,Справа=Ложь,ОшибкаНоль=Ложь,ИгнорироватьСимв="+") Экспорт
	//
	Таб=Новый ТаблицаЗначений; КолТЗ=Таб.Колонки; 
	КолТЗ.Добавить("Фр",,"Фрагмент"); КолТЗ.Добавить("Ур",,"Уровень"); КолТЗ.Добавить("КГ",,"Кол.Групп"); 
	КолТЗ.Добавить("Поз",,"Позиция"); КолТЗ.Добавить("КС",,"Кол.Символов"); 
	//
	Вх=ВходСтр; Ном=0; Дл=СтрДлина(Вх);
	Если Справа тогда
		ПозС0=Дл; 
		Для Сч0=1 по 100 цикл //Слева
			ПозЧ=0; ПозС=0; Ч=Стр_НайтиЧисл(Вх,,Справа,Ложь,"+",ПозЧ,ПозС); Фр=?(ПозЧ=0,Вх,Сред(Вх,ПозС)); ЕстьЧ=(Ч<>Неопределено);
			Если ЕстьЧ тогда Ном=Ном+1; КонецЕсли; 
			Если Ном>КонНомВх тогда Прервать; КонецЕсли;
			Если (Ном>=НачНомВх) и (Ном<=КонНомВх) тогда 	
				Если Фр<>"" тогда СтрТЗ=Таб.Вставить(0); СтрТЗ.Фр=Фр; СтрТЗ.Ур=0; СтрТЗ.Поз=ПозС0-СтрДлина(Фр)+1; СтрТЗ.КС=СтрДлина(Фр); СтрТЗ.КГ=1; КонецЕсли;
				Если ЕстьЧ тогда ; СтрТЗ=Таб.Вставить(0); СтрТЗ.Фр=Ч; СтрТЗ.Ур=1; СтрТЗ.Поз=ПозЧ; СтрТЗ.КС=СтрДлина(""+Ч); СтрТЗ.КГ=1;  КонецЕсли;
			КонецЕсли;
			ПозС0=ПозЧ-1; Вх=?(ПозЧ<1,"",Лев(Вх,ПозЧ-1));
			Если (Вх="") или (ПозС=0) тогда Прервать; КонецЕсли;
		КонецЦикла;	
	Иначе
		ПозС0=1; 
		Для Сч0=1 по 100000 цикл //Слева
			ПозЧ=0; ПозС=0; Ч=Стр_НайтиЧисл(Вх,,Справа,Ложь,"+",ПозЧ,ПозС); Фр=?(ПозЧ=0,Вх,Лев(Вх,ПозЧ-1)); ЕстьЧ=(Ч<>Неопределено);
			Если ЕстьЧ тогда Ном=Ном+1; КонецЕсли; 
			Если Ном>КонНомВх тогда Прервать; КонецЕсли;
			Если (Ном>=НачНомВх) и (Ном<=КонНомВх) тогда 	
				Если Фр<>"" тогда СтрТЗ=Таб.Добавить(); СтрТЗ.Фр=Фр; СтрТЗ.Ур=0; СтрТЗ.Поз=ПозС0; СтрТЗ.КС=СтрДлина(Фр); СтрТЗ.КГ=1; КонецЕсли;
				Если ЕстьЧ тогда ; СтрТЗ=Таб.Добавить(); СтрТЗ.Фр=Ч; СтрТЗ.Ур=1; СтрТЗ.Поз=ПозС0+ПозЧ-1; СтрТЗ.КС=СтрДлина(""+Ч); СтрТЗ.КГ=1;  КонецЕсли;
			КонецЕсли;
			ПозС0=ПозС0+ПозС-1; Вх=?(ПозС<1,"",Сред(Вх,ПозС));
			Если (Вх="") или (ПозС=0) тогда Прервать; КонецЕсли;
		КонецЦикла;	
	КонецЕсли;
	//
	Возврат Таб;
КонецФункции //Стр_Фрагменты(Метод="К",ВходСтр,Разделитель="",ЗаменаКуска="",НачНомВхождения=1,КонНомВхождения=10000000,Справа=Ложь,БезРегистра=Ложь,Масс="")


//    ЧАСТЬ 2. ОБОБЩЕННЫЕ МЕТОДЫ-АЛГОРИТМЫ (4 функции).

//Функция Стр_Сокр(Методы="",ВходСтр,Длина=0,СокрСимвЛ=Неопределено,ЗаменаЛ="",СокрСимвП=Неопределено, ЗаменаП="",СокрСимвС=Неопределено,ЗаменаС=" ")
//Возвращает строку.
//близкие аналоги: СокрЛ(),СокрП(),СокрЛП(); добавлен СокрС().
//Более универсальный подход: заменять можно что угодно на что угодно.
//Можно расширять строку до указанной длины за счет (ЗаменаС). 
//
//  Методы (СОЧИТАЕМЫЕ):
//  "cокрЛ" или "Л"      - Заменить группу символов слева, входящих 
//                         в (СокрСимвЛ) на строку  (ЗаменаЛ)
//  "cокрП" или "П"      - Заменить группу символов справа, входящих 
//                         в (СокрСимвП) на строку  (ЗаменаП)
//  "cокрС" или "С"      - Заменить группы символов в средине строки, 
//                         входящих в (СокрСимвС) на строку  (ЗаменаС)
//                         Строка расширяется за счет (ЗаменаС) до 
//                         указанной длины (Длина)
//
//СокрСимв... - Набор символов со знаком "+"(вхождение) или "-"(невхождение)
//           впереди. По умолчанию соответствуют сокращаемым символам встроенных
//           методов СокрЛ() и сокрП() (впереди добавляется "+").
//           СокрСимвЛ - для метода СокрЛ; 
//           СокрСимвП - для метода СокрП; 
//           СокрСимвС - для метода СокрС; 
//
//Замена.. - строки, заменяющие сокращаемые смволы (СокрСимв...)
//           ЗаменаЛ - для метода СокрЛ
//           ЗаменаП - для метода СокрП
//           ЗаменаС - для метода СокрС
//
Функция Стр_Сокр(Методы="",ВходСтр,Длина=0,СокрСимвЛ=Неопределено,ЗаменаЛ="",СокрСимвП=Неопределено, ЗаменаП="",СокрСимвС=Неопределено,ЗаменаС=" ") Экспорт
	Длин=?(ТипЗнч(Длина)=Тип("Число"),Длина,0);
	Вых=ВходСтр; Дл0=СтрДлина(Вых); Мет=СтрЗаменить(ВРег(Методы),"СОКР",""); 
	Стр1=""; Стр2=""; Стр3="";  Дл1=0; Дл2=0; Дл3=0;
	СС="+ "+Символы.ВК+Символы.ВТаб+Символы.НПП+Символы.ПС+Символы.ПФ+Символы.Таб;
	СокрСимвЛ=?(СокрСимвЛ=Неопределено,СС,СокрСимвЛ);
	СокрСимвП=?(СокрСимвП=Неопределено,СС,СокрСимвП);
	СокрСимвС=?(СокрСимвС=Неопределено,СС,СокрСимвС);
	//
	Если Найти(Мет,"Л")>0 тогда Стр1=""; ДлВ=СтрДлина(Вых);
		Стр_НайтиГр(Вых,СокрСимвЛ,,,0,Дл1); Стр1=Лев(Вых,Дл1);	
		Стр1=?(Дл1=0,"",ЗаменаЛ); Вых=Стр1+Сред(Вых,Дл1+1); 
	КонецЕсли;	
	//
	Если Найти(Мет,"П")>0 тогда ДлВ=СтрДлина(Вых);
		Стр_НайтиГр(Вых,СокрСимвП,Истина,,0,Дл3);	Стр3=Прав(Вых,Дл3);	
		Стр3=?(Дл3=0,"",ЗаменаП); Вых=Лев(Вых,Длв-Дл3)+Стр3; 
	КонецЕсли;	
	//
	Если Найти(Мет,"С")>0 тогда ДлС=Дл0-Дл1-Дл3; СтрС=Сред(ВходСтр,Дл1+1,ДлС); 
		ПозС=1; Если Длин>0 тогда ТЗ=Новый ТаблицаЗначений; Кол=ТЗ.Колонки; Кол.Добавить("Фр"); Кол.Добавить("Ур"); КонецЕсли;
		Для Сч=1 по 1000000 цикл  Дл=0; НомС=-1; Поз=ПозС; Ном=Стр_НайтиГр(СтрС,СокрСимвС,Ложь,Поз,,Дл,ПозС,НомС); 
			Фр=Сред(СтрС,Поз,Дл); Стр2=Стр2+?(Ном=0,Фр,ЗаменаС); Если Длин>0 тогда СТз=ТЗ.Добавить(); СТз.Фр=Фр; СТз.Ур=Ном; КонецЕсли;
			Если Поз=ПозС тогда Прервать; КонецЕсли;
		КонецЦикла;
		Вых=Стр1+Стр2+Стр3; Дл=СтрДлина(Вых); 
		Если (Дл>=Длин) или (Дл=0) тогда Возврат Вых; КонецЕсли;
		Д0=Длин-Дл; ДлЗС=СтрДлина(ЗаменаС); К0=ТЗ.Количество(); К=(К0-1)/2;
		Если (Д0<=0) или (ДлЗС=0) или (Д0<ДлЗС) или (К<=0) тогда Возврат Вых; КонецЕсли;
		//
		//Расширяем строку до указанной длины (Длина)
		Д=Д0+(К*ДлЗС); Ш=Окр(Д/(К*ДлЗС)); Ш=?(Ш=0,1,Ш); Стр=""; Ш=?((Ш*К*ДлЗС)<Д,Ш+1,Ш);
		Для сч=0 по К0-1 цикл С=ТЗ[Сч]; Фр=С.Фр; Ном=С.Ур; 
			Если Д>0 тогда Доп=?(Ном=1,Стр_Дополнить(,?(Ш<Д,Ш,Д),ЗаменаС),Фр); Иначе Доп=?(Ном=1,ЗаменаС,Фр); КонецЕсли;
			Стр=Стр+Доп; Д=?(Ном=1,Д-(Ш*ДлЗС),Д);
		КонецЦикла;				
		Вых=Стр1+Стр+Стр3;	
	КонецЕсли;	
	Возврат Вых;	
КонецФункции //Стр_Сокр(Методы="",ВходСтр,Длина=0,СокрСимвЛ=Неопределено,ЗаменаЛ="",СокрСимвП=Неопределено, ЗаменаП="",СокрСимвС=Неопределено,ЗаменаС=" ")

//Функция Стр_Вхождение(ВходСтр,СтрПоиска="",СтрЗамены=Неопределено,НачНомВхождения=1,КонНомВхождения=10000000,Справа=Ложь,БезРегистра=Ложь,ПозСлед="",МаксНом=0)
//Возвращает строку. 
//Близкий аналог СтрЗаменить(...); Но:
//в исходной строке (ВходСтрока) заменяет разделители (СтрПоиска) 
//на (СтрЗамены) начиная с (НачНомВхождения) до (КонНомерВхождения);
//поиск-замена возможны как слева, так и справа (Справа=Истина); 
//возможен поиск без учета регистра (Безрегистра=Истина).
//Если СтрокаЗамены=Неопределено (только поиск), тогда
//  ПозСлед -  позиция следующего поиска;
//  МаксНом  -  максимальный полученный номер вхождения.
//
//
Функция Стр_Вхождение(ВходСтр,СтрПоиска="",СтрЗамены=Неопределено,НачНомВхождения=1,КонНомВхождения=10000000,Справа=Ложь,БезРегистра=Ложь,ПозСлед="",МаксНом=0) Экспорт
	М=?(СтрЗамены=Неопределено,"Н","З"); Если КонНомВхождения<НачНомВхождения тогда Возврат ВходСтр; КонецЕсли;
	Если (ВходСтр="") или (СтрПоиска="") тогда Возврат ВходСтр; КонецЕсли; ДлР=СтрДлина(СтрПоиска);
	Если БезРегистра тогда ВыхВ=ВРег(ВходСтр); Пар1=ВРег(СтрПоиска); иначе ВыхВ=ВходСтр; Пар1=СтрПоиска; КонецЕсли;
	Стр1=""; Стр2=""; Стр3=""; П=0; ПСлед=Неопределено; Н=0; НачФ=0; ДлФ=0;
	Для Сч=1 по 1000000 цикл П0=П; П=ПСлед; П=Стр_НайтиВх(ВыхВ,Пар1,Справа,П,ПСлед,Начф,ДлФ); 
		Если НачФ=0 Тогда Прервать; КонецЕсли; Н=Н+1; 
		Если М="Н" тогда Если Н=НачНомВхождения тогда ПозСлед=ПСлед; Возврат П; КонецЕсли; Продолжить;
		Иначе Фр=Сред(ВходСтр,НачФ,ДлФ); 
			Если П>0 тогда П1=Сред(ВходСтр,П,ДлР); П2=СтрЗамены; Иначе П1=""; П2=""; КонецЕсли;
			Если Н<НачНомВхождения тогда Стр1=?(Справа,П1+Фр+Стр1,Стр1+Фр+П1);
			ИначеЕсли Н>КонНомВхождения  тогда Стр3=?(Справа,П1+Фр+Стр3,Стр3+Фр+П1);
			Иначе Стр2=?(Справа,П2+Фр+Стр2,Стр2+Фр+?(П>0,П2,""));	
			КонецЕсли;				
		КонецЕсли;		
	КонецЦикла;		
	Если М="Н" Тогда Вых=П; ПозСлед=ПСлед; МахНом=Н;
	Иначе Вых=?(Справа,Стр3+Стр2+Стр1,Стр1+Стр2+Стр3); 
	КонецЕсли;
	Возврат Вых;
КонецФункции //Стр_Заменить(ВходСтр,СтрПоиска="",СтрЗамены="",НачНомВхождения=1,КонНомВхождения=10000000,Слева=Истина)	

//Функция Стр_Фрагменты(Вход,Разделитель="",ЗаменаКуска=Неопределено,НачНомВх=1,КонНомВх=10000000,Справа=Ложь,БезРегистра=Ложь,ТипВых="C",УрРазд=1)
//Работа с фрагментами строки между разделителями (СтрПоиска)
//с (НачНомВх) по (КонНомВх) их вхождения. 
//
//По умолчанию возвращает "кусок" строки (ТиВых="С").
//
//Поиск возможен как слева, так и справа (если Справа=Истина); 
//
//Возможен поиск без учета регистра (если Безрегистра=Истина).
//
//Если определен параметр (ЗаменаКуска) - возвращает
//исходную строку с заменённым куском.
//
//Если (ТипВых="С")- возвращает Строку ("Кусок").
//Если (ТипВых="М")- возвращает Массив фрагментов.
//Если (ТипВых="Т")- возвращает Таблицу значений с колонками:
//  "Фр"  - фрагмент строки между разделителями или разделитель.
//  "Ур"  - номер группировки (0 - для фрагмента; (УрРазд) - для разделителя)
//  "КГ"  - количество групп символов (1, нужна для свёртки); 
//  "Поз" - позиция начала фрагмента/разделителя  в исходной строке;
//  "КС"  - количество символов в группе (длина фрагмента/разделителя);
//  Собственно, в первой колонке - это входная строка 
//  в "разобранном" виде!
//
Функция Стр_Фрагменты(Вход,Разделитель="",ЗаменаКуска=Неопределено,НачНомВх=1,КонНомВх=10000000,Справа=Ложь,БезРегистра=Ложь,ТипВых="C",УрРазд=1) Экспорт
	Замена=(ТипЗнч(ЗаменаКуска)=Тип("Строка")); Нач=НачНомВх; Кон=КонНомВх;
	//
	Если ТипВых="С" тогда Стр1=""; Стр2=""; Стр3="";
	ИначеЕсли ТипВых="М" тогда 	Мас1=Новый Массив; Мас2=Новый Массив; Мас3=Новый Массив; 
    ИначеЕсли ТипВых="Т" тогда ТЗ1=Новый ТаблицаЗначений; КолТЗ=ТЗ1.Колонки; 
		КолТЗ.Добавить("Фр",,"Фрагмент"); КолТЗ.Добавить("Ур",,"Уровень"); КолТЗ.Добавить("КГ",,"Кол.Групп"); 
		КолТЗ.Добавить("Поз",,"Позиция"); КолТЗ.Добавить("КС",,"Кол.Символов"); 
		ТЗ2=ТЗ1.Скопировать(); ТЗ3=ТЗ1.Скопировать();
	КонецЕсли;
	//
	Если (Кон<Нач) или (Вход="") тогда Возврат ?(ТипВых="С","",?(ТипВых="М",Мас2,ТЗ2)) КонецЕсли;
	//
	Если БезРегистра тогда ВыхВ=ВРег(Вход); Пар1=ВРег(Разделитель); иначе ВыхВ=Вход; Пар1=Разделитель; КонецЕсли;
	П=0; Р2=""; ПСлед=Неопределено; Ном=0; НачФ=0; ДлФ=0; ДлР=СтрДлина(Разделитель);
	//
	
	Для Сч=1 по 1000000 цикл П0=П; П=ПСлед; П=Стр_НайтиВх(ВыхВ,Пар1,Справа,П,ПСлед,Начф,ДлФ); 
		Если НачФ=0 Тогда Прервать; КонецЕсли; Ном=Ном+1; Фр=Сред(Вход,НачФ,ДлФ); Р=?(П=0,"",Сред(Вход,П,ДлР));
		//
		Если Ном<=Нач тогда //до начального вхождения
			Если Замена тогда 
				Если ТипВых="С" тогда Стр1=?(Справа, Р+Фр+Стр1, Стр1+Фр+Р);                                           //Строка
				ИначеЕсли ТипВых="М" тогда Если Справа тогда Мас1.Вставить(0,Фр); иначе Мас1.Добавить(Фр); КонецЕсли; //Массив
				Иначе                                                                                                 //Таблица
					Если Фр<>"" тогда Если Справа тогда  СтрТЗ=ТЗ1.Вставить(0); иначе СтрТЗ=ТЗ1.Добавить(); КонецЕсли;   
						СтрТЗ.Фр=Фр; СтрТЗ.Ур=0; СтрТЗ.КГ=1; СтрТЗ.КС=ДлФ; СтрТЗ.Поз=НачФ;
					КонецЕсли;
					Если Р<>"" тогда Если Справа тогда  СтрТЗ=ТЗ1.Вставить(0); иначе СтрТЗ=ТЗ1.Добавить(); КонецЕсли;   
						СтрТЗ.Фр=Р; СтрТЗ.Ур=УрРазд; СтрТЗ.КГ=1; СтрТЗ.КС=ДлР; СтрТЗ.Поз=П;
					КонецЕсли;		
				КонецЕсли;
			КонецЕсли;				
		ИначеЕсли Ном<=Кон тогда РР=?(Ном<Кон,Р,""); Р2=?(Ном=Кон,Р,Р2); //между нач и кон . вхождением
			Если не Замена тогда 
				Если ТипВых="С" тогда Стр2=?(Справа, РР+Фр+Стр2, Стр2+Фр+РР);                                         //Строка
				ИначеЕсли ТипВых="М" тогда Если Справа тогда Мас2.Вставить(0,Фр); иначе Мас2.Добавить(Фр); КонецЕсли; //Массив
				Иначе                                                                                                 //Таблица
					Если Фр<>"" тогда Если Справа тогда  СтрТЗ=ТЗ2.Вставить(0); иначе СтрТЗ=ТЗ2.Добавить(); КонецЕсли;   
						СтрТЗ.Фр=Фр; СтрТЗ.Ур=0; СтрТЗ.КГ=1; СтрТЗ.КС=ДлФ; СтрТЗ.Поз=НачФ;
					КонецЕсли;
					Если РР<>"" тогда Если Справа тогда  СтрТЗ=ТЗ2.Вставить(0); иначе СтрТЗ=ТЗ2.Добавить(); КонецЕсли;   
						СтрТЗ.Фр=РР; СтрТЗ.Ур=УрРазд; СтрТЗ.КГ=1; СтрТЗ.КС=ДлР; СтрТЗ.Поз=П;
					КонецЕсли;		
				КонецЕсли;		
			КонецЕсли;
		Иначе РР=?(Ном=(Кон+1),Р2,""); //после конечного вхождения
			Если Замена тогда 
				Если ТипВых="С" тогда Стр3=?(Справа, Р+Фр+Стр3+РР, РР+Стр3+Фр+Р);                                     //Строка
				ИначеЕсли ТипВых="М" тогда Если Справа тогда Мас3.Вставить(0,Фр); иначе Мас3.Добавить(Фр); КонецЕсли; //Массив
				Иначе                                                                                                 //Таблица
					Если Фр<>"" тогда Если Справа тогда  СтрТЗ=ТЗ3.Вставить(0); иначе СтрТЗ=ТЗ3.Добавить(); КонецЕсли;   
						СтрТЗ.Фр=Фр; СтрТЗ.Ур=0; СтрТЗ.КГ=1; СтрТЗ.КС=ДлФ; СтрТЗ.Поз=НачФ;
					КонецЕсли;
					Если РР<>"" тогда Если Справа тогда  СтрТЗ=ТЗ3.Вставить(0); иначе СтрТЗ=ТЗ3.Добавить(); КонецЕсли;   
						СтрТЗ.Фр=РР; СтрТЗ.Ур=УрРазд; СтрТЗ.КГ=1; СтрТЗ.КС=ДлР; СтрТЗ.Поз=П;
					КонецЕсли;		
				КонецЕсли;	
			КонецЕсли;
		КонецЕсли;				
		//
		Если (не Замена) и (Ном=Кон) тогда Прервать; КонецЕсли; //Получили кусок, для нас достаточно
		//	
	КонецЦикла;		
	//
	//ЗАМЕНА КУСКА
	Если Не Замена тогда Вых=Стр2; //Кусок строки
		Если ТипВых="С" тогда Вых=Стр2
		ИначеЕсли ТипВых="М" тогда Вых=Мас2;
		Иначе Вых=ТЗ2;	
		КонецЕсли;	
	иначеЕсли Ном>=Кон тогда //Замена куска и после Кон.
		Если ТипВых="С" тогда Вых=?(Справа,Стр3+ЗаменаКуска+Стр1,Стр1+ЗаменаКуска+Стр3);
		ИначеЕсли ТипВых="М" тогда		
			Если Справа тогда Вых=Мас3; Вых.Добавить(ЗаменаКуска); Для каждого э из Мас1 цикл Вых.Добавить(Э); КонецЦикла;
			Иначе Вых=Мас1; Вых.Добавить(ЗаменаКуска); Для каждого э из Мас3 цикл Вых.Добавить(Э); КонецЦикла;
			КонецЕсли;		
		Иначе	
			Если Справа тогда Вых=ТЗ3; СтрТЗ=Вых.Добавить(); //(ЗаменаКуска); 
				Для каждого э из ТЗ1 цикл СтрТ=Вых.Добавить(); СтрТ=Э; КонецЦикла;
			Иначе Вых=ТЗ1; СтрТЗ=Вых.Добавить(); //(ЗаменаКуска); 
				Для каждого э из ТЗ3 цикл СтрТ=Вых.Добавить(); Стрт=Э; КонецЦикла;
			КонецЕсли;		
		КонецЕсли;	
	Иначе  
		Если ТипВых="C" тогда Вых=Стр1;
		ИначеЕсли ТипВых="М" тогда Вых=Мас1;
		Иначе Вых=ТЗ1;	
		КонецЕсли;	
	КонецЕсли;	
	//	
	МаксНом=Ном;
	Возврат Вых;
КонецФункции //Стр_Фрагменты(Метод="К",ВходСтр,Разделитель="",ЗаменаКуска="",НачНомВхождения=1,КонНомВхождения=10000000,Справа=Ложь,БезРегистра=Ложь,Масс="")

//Функция Стр_Разбить(ВходСтр,Длины="",Метод="Р",БезОстатака=Ложь,Разделители=". ,:-+=<>?!;",ОстатокСтроки="")
//Возвращает масиив с подстроками.
//
//ВХОД:
//  ВходСтрока  - входная строка;
//  Длины       - Массив с длинами Подстрок или Число - длина подстрок;
//  Метод       - "РазбитьЖ" или "Ж" - "Жесткий" перенос (с дефисом);
//              - "РазбитьМ" или "М" - "Мягкий" перенос (по границе слов);
//              - "РазбитьР" или "Р" - "Разрезание" по указанной длине;
//  БезОстатка  - до конца строки; подстроки с номерами большими
//                количества длин в массиве (Длины) получают длину из
//                последнего элемента этого массива; 
//  Разделители - строка из символов- разделителей слов.
//ВЫХОД:
//  ОстатокСтроки - если БезОстатка=Ложь - тогда остаток строки;
//                  иначе - строка из подстрок, разделенных символом ПС( ПереводСтроки);
Функция Стр_Разбить(ВходСтр,Длины="",Метод="Ж",БезОстатка=Ложь,Разделители=". ,:-+=<>?!;",ОстатокСтроки="") Экспорт
	Если ТипЗнч(Длины)=Тип("Число") тогда МДл=Новый Массив; МДл.Добавить(Длины); Иначе МДл=Длины; КонецЕсли;
	КДл=МДл.Количество(); ДлП=МДл[КДл-1]; Стоп=?(БезОстатка,0,1); Вых=ВходСтр; Мет=ВРег(Прав(Метод,1));
	Перенос=Мет; Строка0=Вых; Стр=Вых; МС=Новый Массив;
		//
	//Создаем строку в нижнем регистре с "универсальным" разделителем слов - Символ(0);
	Р=Символ(0); Строка1=НРег(Строка0); Разделители=?(Разделители="",". ,:-+=<>?!;",Разделители);
	Для сч=1 по СтрДлина(Разделители) цикл Строка1=СтрЗаменить(Строка1,Сред(Разделители,Сч,1),Р); КонецЦикла;	
	//Переносы в цикле по длинам подстрок
	СтрС="йцкнгшщзхъфвпрлджчсмтьб"; СтрГ="ёуеыаоэяию"; СтрР=СтрС+СтрГ; СтрЦ="0123456789"; Пер=0; Ч=СтрДлина(Строка1); 
	Для Сч=1 по Ч цикл Если СтрДлина(Строка1)=0 тогда Прервать; КонецЕсли; //Цикл по длинам подстрок
		Если (Сч>Кдл) и (Стоп=1) тогда Прервать; КонецЕсли;
		Дл=?(Сч>=КДл,ДлП,0+МДл[Сч-1]);  
		//
		Если Перенос="Р" тогда Пер=0; Л=Дл; //Просто разрезаем строку
		Иначе                               //"Мягкий"  или "Жесткий" переносе		
			//Текущая подстрока и фрагмент после последнего Разделителя
			Стр1=Лев(Строка1,Дл); Л1=СтрДлина(Стр1);  С_1=Сред(Стр1,Л1,1); Г_1=?(Найти(СтрГ,С_1)=0,0,1); ЛР1=0; К1=СтрЧислоВхождений(Стр1,Р); КГ1=0; КН1=0;
			Для Сч1=1 по Л1 цикл Л=Л1-Сч1+1; С=Сред(Стр1,Л,1); Если С=Р тогда ЛР1=Л; Прервать; КонецЕсли;
				КГ1=КГ1+?(Найти(СтрГ,С)>0,1,0); КН1=КН1+?(Найти(СтрР,С)=0,1,0);	
			КонецЦикла;		
			Л=Л1; Фр1Л=Дл-ЛР1; //Длина последнего фрагмента текущей строки;
			//
			//Следующая подстрока и фрагмент до первого разделителя
			Стр2=Сред(Строка1,Дл+1); К2=СтрЧислоВхождений(Стр2,Р); ЛР2=Дл+?(К2=0,СтрДлина(Стр2),Найти(Стр2,Р)); Пер=2; КГ2=0; КН2=0;
			Фр2Л=ЛР2-Дл-1; //Длина первого фрагмента следующей строки
			Для Сч2=Дл+1 по ЛР2-1 Цикл С=Сред(Строка1,Сч2,1); КГ2=КГ2+?(Найти(СтрГ,С)>0,1,0); КН2=КН2+?(Найти(СтрР,С)=0,1,0); КонецЦикла;		
			С1=Сред(Строка1,Л+1,1);		
			//
			Если Перенос="М" тогда Л=?(ЛР1=0,Дл,ЛР1); Пер=1; //Только мягкий перенос
			ИначеЕсли (С_1=Р) или (Дл>=Ч) тогда Пер=1; //Мягкий перенос - попали на Разделитель или закончилась строка
			ИначеЕсли (К1=0) и ((КГ1=0) или (КН1>0)) тогда Пер=0; Л=Дл;//Нет Разделителей - просто разрываем строку
			ИначеЕсли (КГ1=0) Или (КН1>0) тогда Пер=1; Л=?(ЛР1=0,Дл,ЛР1); //Мягкий перенос
			Иначе Пер=2; //Попытка "жесткого" переноса	
				Для Сч1=1 по Дл-ЛР1 цикл  Л=Дл-Сч1;  С_1=Сред(Строка1,Л,1); Г_1=?(Найти(СтрГ,С_1)=0,0,1); Н_1=?(Найти(СтрР,С_1)=0,1,0);
					//
					КН1=КН1-Н_1;  Фр1Л=Фр1Л-1; КГ2=КГ2+Г_1; КН2=КН2+Н_1; Фр2Л=Фр2Л+1;
					//
					Если С_1=Р тогда Пер=1; Прервать; КонецЕсли; //Попали на разделитель - мягкий перенос
					Если (КН1>0) или (КГ1=0) или (Фр1Л<2) тогда Л=ЛР1; Пер=1; Прервать; КонецЕсли;	//Мягкий пренос	
					Если КН2>0 тогда Пер=0; Прервать; КонецЕсли; //Разрыв строки
					Если Фр2Л=0 тогда Пер=1; Прервать; КонецЕсли; //Пустой фрагмент на следующей строке
					Если (КГ2=0) или (Фр2Л<2) тогда продолжить; КонецЕсли; //		
					//
					Если (С_1="ь") или  (С_1="ъ") или (С_1="й") тогда Пер=2; Прервать; КонецЕсли; //Всегда Жесткий перенос
					//
					С_2=Сред(Строка1,Л-1,1); С_3=Сред(Строка1,Л-2,1); С1=Сред(Строка1,Л+1,1); С2=Сред(Строка1,Л+2,1); С3=Сред(Строка1,Л+3,1); 
					Если (Фр2Л<2) и (С1=Р) тогда Продолжить; КонецЕсли;
					//
					//нельзя переносить символы "ь","ъ" или "й" первыми
		            Если (С1="ь") или  (С1="ъ") или (С1="й") тогда Продолжить; КонецЕсли; 
					//
					Г_3=?(Найти(СтрГ,С_3)=0,0,1); Г_2=?(Найти(СтрГ,С_2)=0,0,1);  
					Г1=?(Найти(СтрГ,С1)=0,0,1);  Г2=?(Найти(СтрГ,С2)=0,0,1);Г3=?(Найти(СтрГ,С3)=0,0,1); 
					//
					//Нельзя переносить "последняя согласная - первая гласная"
					Если (Г_1=0) и (Г1=1) тогда Продолжить; КонецЕсли;
					//
					//Нельзя переносить "последняя гласная - первые две согласные"
					Если (Г_1=1) и (Г1=0) и (Г2=0) тогда Продолжить; КонецЕсли;
					//
					//Нельзя переносить "последние две согласные (кроме "рт") - первая согласная"
					Если (Г_2=0) и (Г_1=0) и ((С_2+С_1)<>"рт") тогда Продолжить; КонецЕсли;
					//
					//Нельзя 'разбивать' "рт" при последующей согласной
					Если (С_1="Р") и (С1="т") и (Г2=0) тогда Продолжить; КонецЕсли;
					//
					Прервать;
					//
				КонецЦикла;	
			КонецЕсли;		
		КонецЕсли;	//по типам переноса
		//
		Стр=Лев(Строка0,Л); Стр1=Лев(Строка1,Л); Если Перенос="Ж" тогда Стр=Стр+?(Пер=2,"-",""); КонецЕсли;	
		Фл=?(Сред(Строка0,Л+1,1)=" ",1,0);  Строка0=Сред(Строка0,Л+1+Фл); Строка1=Сред(Строка1,Л+1+Фл);	
		//
		МС.Добавить(Стр);
	КонецЦикла;	//по длинам подстрок
	//
	Если не БезОстатка тогда ОстатокСтроки=Строка0; 
	Иначе ОстатокСтроки=""; 
		Для Каждого С из МС цикл 
			Если СтрЗаменить(С," ","")="" тогда Продолжить; КонецЕсли;
			ОстатокСтроки=ОстатокСтроки+СокрП(С)+Символы.ПС; 
		КонецЦикла;
		
	//Сообщить("ОстатокСтроки="+ОстатокСтроки);	
		
	КонецЕсли;	
	Возврат МС;
КонецФункции //Стр_Разбить(ВходСтр,Длины="",Метод="Р",БезОстатка=Ложь,Разделители=". ,:-+=<>?!;",ОстатокСтроки="")

//    ЧАСТЬ 3. УНИВЕРСАЛЬНАЯ ФУНКЦИЯ.
//    Своих алгоритмов не имеет.Некий программный интерфейс,
//    позволяющий совмещать сразу несколько методов

//Функция Стр_(Вход,Методы="",Подметоды="",Парам1="",Парам2="",Позиции_Номера_Длины="",ДопВыход="")
//Универсальная функция работы со строкой.
//Пограммный интерфейс, позволяющийй применять к строке
//сразу несколько методов. Своих алгоритмов не имеет.
//Возвращает Строку или Массив подстрок или Таблицу Значений 
//
//ПАРАМЕТРЫ:
//Методы     - Наименования или односимвольные коды методов;
//Подметоды  - Уточненеия, варианты  основного метода (имена или коды); 
//Вход       - Строка или Массив подстрок или Таблица Значений; 
//Парам1     - Строка поиска, разделитель, заменяемые символы, фильтр для группировок;
//Парам2     - Заменяющие-дополняющие символы;
//Позиции_Номера_Длины - Строка Чисел через разделители или Массив;
//ДопВыход   - Дополнительный выход (наряду с возращаемым значением);
//
//________________________
//КРАТКОЕ ОПИСАНИЕ МЕТОДОВ И ПОДМЕТОДОВ (УТОЧНЕНИЙ)
//
//Поддерживается как полный синтаксис (название метода в любом регистре),
//так и краткий - односимвольные коды в любом регистре.
//
//Отдельные Методы в параметре "Методы" и отдельные Подметоды в параметре
// "Подметоды" для наглядности могут быть разделены любыми символами из ",: ;". 
//
//Для наглядности будем в дальнейшем выделять код Метода и код 
//Подметода в их полном названии Заглавной буквой. 
//
//Методы условно разделены две группы:
//  - "Совмещаемые" методы. Могут применяться
//     как совместно дуг сдругом, так и совместно с любым "Монопольным" 
//     ("Основным") методом второй группы.
//  - "Монопольные" - могут применятьс совместно только с методами 
//     первой группы ("Совмещаемыми", которые выполняются первыми)
//
//Сомещаемые Подметоды выделяются (+), Монопольные - (-)
//
//
//
//
//МЕТОДЫ РАБОТЫ С ПРОБЕЛАМИ ("СОВМЕЩАЕМЫЕ")
//  "сокрЛ"(+) - сократить (СокрСимв) сЛева
//  "сокрП"(+) - сократить (СокрСимв) сПрава
//  "сокрС"(+) - сократить СокрСимв)поСредине до одного
//	  Примеры вариантов:"сокрЛП","сокрЛПС","ЛП","ЛПС","ЛПсокрС" и т. д.	
//    Основаны на функции Стр_Сокр(...).
//    Методы возвращают Строку или массив Строк (зависит от Входа).          
//
//"МОНОПОЛЬНЫЕ" МЕТОДЫ
//_____________________
// "Числа"        - Возвращает Число или таблицу значений.
//                  ДопВыход - позиция первого после числа символа.
//                  (См. "Стр_НайтиЧисл()").
//   Подметод="Ошибканоль"(+)- при ошибке возвращет "0" вместо "Неопределено";
//   Подметод="сПрава"(+)    - отсчет идет справа;
//   Подметод="Число"(-)     - получаем Число слева или справа;
//   Подметод="Таблица"(-)   - возвращает ТЗ с числами и фрагментами строки;
//_____________________
// "расШирить"       -  расширение строки указанными символами между словами 
//                  до длины, указанной в Позиции_Номера_Длины. 
//                  Возвращает Строку.
//_____________________
// "Дополнить"    - дополнение строки указанными в Парам2 символом до длины,
//                  указанной в Позиции_Номера_Длины. Возвращает Строку.
//   Подметод="сЛева" - дополнение строки слева
//_____________________
// "Кодысимволы"         - коды (через ",") из строки символов (и наоборот!)
//   Подметод="Коды"(-) - получить коды (через ","), в ДоВыход - массив Кодов
//   Подметод="Символы"(-) - получить строку символов из с троки или массива кодов
//_____________________
// "Заменитьсимволы"  - Заменяет в строке между позициями из (Позиции_Номера_Длины)
//                      символы из (Парам1) на соответствующие п/п симолы из (Парам2);
//_____________________
// "Вхождение"  - Работа с разделителями (вхождениями подстрок)
//   Подметод="сПрава"(+) - отсчёт номера вхождения (Позиции_Номера_Длины)
//                          разделителя (Парам1) справа
//   Подметод="Безрегистра"(+) - поиск вхождения без учета регистра символов
//   Подметод="Найти"(-) - поиск вхождения с заданным номером
//   Подметод="Заменить"(-) - Замена разделителей в интервале вхождений 
//                            (Позиции_Номера_Длины) на (Парам2)
//_____________________
// "Фрагменты"    - Работа с фрагментами строки между разделителями (Парам1)
//                  в интервале вхождений (Позиции_Номера_Длины).
//                  По умолчанию возвращает "кусок" строки.
//   Подметод="сПрава"(+) - поиск разделителя справа.
//   Подметод="Безрегистра"(+) - поиск разделителя без учета регистра.
//   Подметод="ЗаменитьКусок"(+) - в исходной строке заменяет кусок строки
//                                 на (Парам2);
//   Подметод="Массив"(-) - вместо "куска" возвращает массив с фрагментами строки
//   Подметод="Таблица"(-) - возвращает ТЗ с детальной информацией 
//                          (см. метод "Стр_Фрагменты()").
//_____________________
// "разбитьЖ"     - разбить строку "жестко" ("жесткий" перенос, с дефисом).
//                  (см . метод "Стр_ПеренестиПоСлогам()")
//   Подметод="Безостатка"(+) - разбиение производиться до конца строки,
//                              при этом ,в случае необходимости,используется 
//                              последняя из длин, заданных в (Позиции_Номера_Длины).
//   Подметод="сокрП"(+) - сократить для фрагментов пробелы слева,
//   Подметод="сокрЛ"(+) - сократить для фрагментов пробелы справа,
//   Подметод="сокрС"(+) - сократить для фрагментов пробелы посредине,
//   Подметод="расШирить"(+) - "расширить" фрагменты до длин ,указанных
//                             в (Позиции_Номера_Длины);
//   Подметод="Дополнить"(-) - дополнить фрагменты символами из (Парам2) до
//                            длин из (Позиции_Номера_Длины);
//   Подметод="дополнитьЗ"(-) - дополнить только завершающий фрагмент символами 
//                              из (Парам2) до длин из (Позиции_Номера_Длины);
//_____________________
// "разбитьМ"     - разбить строку "мягко" ("мягкий" перенос, без дефиса).
//                  (см . метод "Стр_ПеренестиПоСловам()")
//   Подметоды - те же, что и в методе "разбитьМ".
//_____________________
// "разбитьР"     - "разрезать" строку.
//                  (см . метод "Стр_ПеренестиПоСловам()")
//   Подметоды - те же, что и в методе "разбитьМ".
//_____________________
// "Интерпретировать"  - создать массив согласно определенному синтаксису
//                       см метод "Стр_Интерпретировать()")
//   Подметод="дляФильтра" - используется синтаксис Фильтра.  
//_____________________
// "Группировки"  - создать ТЗ согласно мнгоуровневому Фильтру
//                       см метод "Стр_вТаблГр()".
//   Подметод="раскрыватьФильтр" - используется синтаксис Фильтра.  
//_____________________
// "расЩепление"  - создать массив согласно ситеме вложенных разделителей.
//                       см метод "Стр_вТаблВх()".
//   Подметод="раскрыватьРазделители" - используется синтаксис 
//                       метода "Стр_Интерпретировать()".  
//
//
//###########################################################################################################################################
Функция Стр_(Методы="",Подметоды="",Вход,Парам1="",Парам2="",Позиции_Номера_Длины="",ДопВыход="") ЭКСПОРТ
	//Определяем Коды Методов:
	Мет=ВРег(Методы); ТипВх=ТипЗнч(Вход); Вых=Вход;
	
	Мет=СтрЗаменить(Мет,"СОКР",""); Мет=СтрЗаменить(Мет,"РАЗБИТЬ",""); 
	Мет=СтрЗаменить(Мет,"РАСШИРИТЬ","Ш"); Мет=СтрЗаменить(Мет,"ВТАБЛИЦУ","Т"); Мет=СтрЗаменить(Мет,"РАСЩЕПЛЕНИЕ","Щ"); 
	Стр="ЧИСЛА,ДОПОЛНИТЬ,КОДЫСИМВОЛЫ,ЗАМЕНИТЬСИМВОЛЫ,ВХОЖДЕНИЕ,ФРАГМЕНТЫ,ИНТЕРПРЕТИРОВАТЬ,ГРУППИРОВКИ"; Стр1=""; К=СтрЧислоВхождений(Стр,",")+1;
	Для Сч=1 по  К цикл Н=Найти(Стр,","); С=?(Н=0,Стр,Лев(Стр,Н-1)); Стр=Сред(Стр,Н+1); Мет=СтрЗаменить(Мет,С,Лев(С,1)); КонецЦикла;
	Мет=Стр_Сокр("ЛПС",Мет); Мет=Стр_ЗаменитьСимволы(Мет,";: ","");
	Ут=ВРег(Подметоды); Ут=Стр_ЗаменитьСимволы(Ут,",;: ","");
	//
	//
	//"СОВМЕЩАЕМЫЕ" МЕТОДЫ 
	//____________________________________________________________________________________
	Мет1=Стр_ЗаменитьСимволы(Мет,"ЛПС","");
	Если СтрДлина(Мет1)<>СтрДлина(Мет) тогда Дл=Позиции_Номера_Длины;
		Если ТипВх=Тип("Строка") тогда Вых=Стр_Сокр(Мет,Вых,Дл);
		ИначеЕсли ТипВх=Тип("Массив") тогда Для Каждого Стр из Вых Цикл Стр=Стр_Сокр(Мет,Стр,Дл); КонецЦикла;
		КонецЕсли;
		Мет=Мет1;	
	КонецЕсли;			
	//____________________________________________________________________________________
	//
	//
	//
	//"МОНОПОЛЬНЫЕ" МЕТОДЫ	
	//Подготовка Выхода и  массива из (Позиции_Номера_Длины): 
	Т=ТипЗнч(Позиции_Номера_Длины); МДл=новый Массив; Стоп=0;
	Если (Позиции_Номера_Длины="") или (Позиции_Номера_Длины=Неопределено) тогда Стоп=1;
	ИначеЕсли Т=Тип("Строка") тогда Стр=Позиции_Номера_Длины; Стр=Стр_Сокр("ЛПС",Стр); Стр=Стр_ЗаменитьСимволы(Стр,";: ",",,,");
		Для сч=1 по 1000000 цикл Н=Стр_НайтиВх(Стр,","); С=?(Н=0,Стр,Лев(Стр,Н-1)); 
			Попытка МДл.Добавить(Число(С)); Исключение Стоп=1; Прервать; КонецПопытки; Стр=Сред(Стр,Н+1); 
			Если Н=0 тогда Прервать; КонецЕсли;	
		КонецЦикла;
	ИначеЕсли Т=Тип("Массив") тогда Мдл=Позиции_Номера_Длины; К1=МДл.Количество(); Попытка С=0+МДл[К1-1]; Исключение Стоп=1; МДл.Удалить(К1-1); КонецПопытки;	
	ИначеЕсли Т=Тип("Число") тогда МДл.Добавить(Позиции_Номера_Длины);   	          
	КонецЕсли;	
	КДл=МДл.Количество(); ДлП=?(КДл=0,0,МДл[КДл-1]); ДлПар1=СтрДлина(Парам1); ДлПар2=СтрДлина(Парам2); 
	//
	
	//____________________________________________________________________________________
	//1. "Числа". Работа с Числами. В ДопВыход - "остаток" строки. (+)
	Если Мет="Ч" тогда 
		Ут=СтрЗаменить(СтрЗаменить(Ут,"ОШИБКАНОЛЬ","О"),"СПРАВА","П"); 
		Ут=СтрЗаменить(СтрЗаменить(СтрЗаменить(Ут,"ЧИСЛО","Ч"),"НАЙТИ","Н"),"ТАБЛИЦА","Т"); 
		сПрава=(Найти(Ут,"П")>0); Ош0=(Найти(Ут,"О")>0);  ПозЧ=0; ПозС=0; 
		Если (Найти(УТ,"Н")>0) или (Найти(УТ,"Т")>0) тогда ИгнСимв=?(Парам1="","+",Парам1); 
		иначе ИгнСимв="+ "+Символы.ВК+Символы.ВТаб+Символы.НПП+Символы.ПС+Символы.ПФ+Символы.Таб; 
		КонецЕсли;
		Если КДл=0 тогда Нач=1; Кон=10000; ИначеЕсли КДл=1 тогда Нач=МДл[0]; Кон=Нач+1; Иначе Нач=МДл[0]; Кон=МДл[1]; КонецЕсли;
		//
		Если Найти(Ут,"Т")>0 тогда Выход=Стр_вТаблЧисел(Вых,Нач,Кон,Справа,Ложь,ИгнСимв); 
		Иначе Выход=Стр_НайтиЧисл(Вых,Нач,Справа,Ош0,ИгнСимв,ПозЧ,ПозС); ДопВыход=?(ПозС=0,"",Сред(Вых,ПозС));
		КонецЕсли;			
		Возврат Выход;
	//____________________________________________________________________________________
	//2. "расШирить". Расширение строки пробелами между словами 
	ИначеЕсли Мет="Ш" тогда 
		Возврат Стр_Сокр("С",Вых,?(КДл=0,0,МДл[0]));
	//____________________________________________________________________________________	
	//3. "Дополнить". Дополненение строки символами (Парам2)(+) 
	ИначеЕсли (ВРег(Мет)="Д") или (ВРег(Мет)="ДОПОЛНИТЬ") тогда 
		Возврат Стр_Дополнить(Вых,МДл[0],Парам2,УТ="Л");
	//_______________________________________________________________________________________________		
	//4. "Кодысимволы". Работа с Кодами и символами (+)
	ИначеЕсли Мет="К" тогда  
		//Вход - строка из символов или из кодов через запятую или массив с кодами.
		//Возвращает - строку из кодов через запятую или из символов.
		//ДопВыход - массив скодами или символами.
		ДопВыход=Новый Массив; Если Вых="" тогда Возврат ""; КонецЕсли;
		Если КДл=0 тогда Нач=1; Кон=100000000; ИначеЕсли КДл=1 тогда Нач=МДл[0]; Кон=Нач; Иначе Нач=МДл[0]; Кон=Мдл[1];	КонецЕсли;
		Если Найти(Ут,"С")>0 тогда Возврат Стр_Символы(Вых,Нач,Кон,ДопВыход);
		Иначе Возврат Стр_Коды(Вых,Нач,Кон,ДопВыход);
		КонецЕсли;	
		//Возврат Стр_КодыСимволы(Вых,Нач,Кон,Найти(Ут,"С")>0,ДопВыход);
	//_________________________________________________________________________________________	
	//5. "Заменитьсимволы". Замена символов п/п (+)
	ИначеЕсли Мет="З" тогда 
		Если КДл=0 тогда П1=1; П2=10000000; ИначеЕсли КДл=1 тогда П1=МДл[0]; П2=10000000; Иначе П1=МДл[0]; П2=МДл[1] КонецЕсли;
		Возврат Стр_ЗаменитьСимволы(Вых,Парам1,Парам2,П1,П2); //поСимвольная замена 
	//__________________________________________________________________________________________	
	//6. "Вхождение". Найти Разделитель или заменить разделители (слева или справа)(+) 
	ИначеЕсли Мет="В" тогда 
		Если КДл=0 тогда Н1=1; Н2=1; ИначеЕсли КДл=1 тогда Н1=МДл[0]; Н2=Н1; Иначе Н1=МДл[0]; Н2=МДл[1] КонецЕсли;
		Ут=СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(Ут,"СПРАВА","П"),"БЕЗРЕГИСТРА","Б"),"НАЙТИ","Н"),"ЗАМЕНИТЬ","З");
		Пар2=?(Найти(Ут,"З")=0,Неопределено,Парам2);
		Возврат Стр_Вхождение(Вых,Парам1,Пар2,Н1,Н2,Найти(Ут,"П")>0,Найти(Ут,"Б")>0,ДопВыход);
	//_____________________________________________________________________________________________	
	//7. "Фрагменты". Работа с фрагментами строки между разделителями (+)
	ИначеЕсли Мет="Ф" тогда  
		Ут=СтрЗаменить(Стрзаменить(СтрЗаменить(Ут,"ЗАМЕНИТЬКУСОК","З"),"СПРАВА","П"),"БЕЗРЕГИСТРА","Б");
		Ут=СтрЗаменить(Стрзаменить(СтрЗаменить(Ут,"МАССИВ","М"),"ТАБЛИЦА","Т"),"СТРОКА","С");
		Зам=(Найти(Ут,"З")>0); Пра=(Найти(УТ,"П")>0); Без=(Найти(УТ,"Б")>0); ТипВых=Стр_ЗаменитьСимволы(Ут,"ЗПБ ,:;","");
		Если КДл=0 тогда Нач=0; Кон=1; ИначеЕсли КДл=1 тогда Нач=МДл[0]; Кон=Нач+1; Иначе Нач=МДл[0]; Кон=Мдл[1];	КонецЕсли;
		Пар2=?(Зам,Парам2,Неопределено); ТипВых=?(ТипВых="","С",ТипВых);
		Возврат Стр_Фрагменты(Вых,Парам1,Пар2,Нач,Кон,Пра,Без,ТипВых,ДопВыход); 			
	//_______________________________________________________________________________________________		
	//8. "Разбить...". Разбиение-перенос (+)
	ИначеЕсли (Мет="Ж") или (Мет="М") или (Мет="Р") тогда 
		Ут=ВРег(Ут); Ут=СтрЗаменить(Ут,"СОКР",""); Ут=СтрЗаменить(Ут,"ДОПОЛНИТЬЗ","З"); Ут=СтрЗаменить(Ут,"ДОПОЛНИТЬ","Д"); 
		Ут=СтрЗаменить(СтрЗаменить(Ут,"РАСШИРИТЬ","Ш"),"БЕЗОСТАТКА","Б");
		//
		МС=Стр_Разбить(Вых,МДл,Мет,Найти(Ут,"Б")>0,Парам1,ДопВыход);
		//
		Если Ут="" тогда Возврат МС; КонецЕсли;
		//
		//Далее - Уточнения (для каждого элемента выходного массива):
		К=МС.Количество(); ФлЗ=0; Если ((Найти(Ут,"Ш")>0) и (Найти(Ут,"Д")>0)) или (Найти(Ут,"З")>0) тогда К=К-1; ФлЗ=1; КонецЕсли;
		Ут1=Стр_ЗаменитьСимволы(Ут,"ЛПСШ",""); ФлШ=?(Найти(Ут,"Ш")>0,1,0); Если (ФлШ=1) и (Найти(Ут,"С")=0) тогда Ут=Ут+"С"; КонецЕсли;
		Если (Ут1<>Ут) или (Найти(Ут,"Д")>0) тогда  
			Для сч=1 по К цикл Стр=МС[Сч-1]; Дл=?(Сч>=КДл,ДлП,Мдл[Сч-1]); //цикл по выходному массиву
				Если Ут1<>Ут тогда МС[Сч-1]=Стр_Сокр(Ут,Стр,?(ФлШ=1,Дл,0)); Иначе МС[Сч-1]=Стр_Дополнить(Стр,Дл,Парам2); КонецЕсли;				
			КонецЦикла;	//по выходному массиву
		КонецЕсли;	
		//
		//Дополнение последней подстроки
		Если ФлЗ=1 тогда Стр=СокрП(МС[К]); Дл=?(К<КДл,МДл[К],ДлП); МС[К]=Стр_Дополнить(Стр,Дл,Парам2); КонецЕсли;	
		//	
		Возврат МС;
	//________________________________________________________________________________________________
	//9. "Интерпретировать". передача в массив согласно установленому синтаксису	
	ИначеЕсли Мет="И" тогда 
		Ут=СтрЗаменить(Ут,"ДЛЯ ФИЛЬТРА","ф"); 
		Возврат Стр_Интерпретировать(Вых,Найти (Ут,"Ф"))		
	//________________________________________________________________________________________________
	//9. "Группировки". Группировки символов в строке (+)	
	ИначеЕсли Мет="Г" тогда 
		Ут=СтрЗаменить(Ут,"ЧАСТОТНОСТЬ","Ч");  Ут=СтрЗаменить(Ут,"РАСКРЫВАТЬФИЛЬТР","ф"); Ут=СтрЗаменить(Ут,"ВЫВОДИТЬГРУППЫ","Г"); 
		//
		Возврат Стр_ВТаблГр(Вых,Парам1,Найти(УТ,"ф")>0,Найти(УТ,"Г")>0,Найти(УТ,"Ч")>0,ДопВыход);
	//________________________________________________________________________________________________
	//11. "расЩепление" .Строка - в ТЗ по вложенным разделителям.	
	ИначеЕсли Мет="Щ" тогда 
		Ут=СтрЗаменить(СтрЗаменить(Ут,"РАСКРЫВАТЬРАЗДЕЛИТЕЛИ","Р"),"БЕЗРЕГИСТРА","Б");
		Возврат Стр_ВТаблВх(Вых,Парам1,Найти(Ут,"Р")>0,Найти(Ут,"Б")>0);
	//_______________________________________________________________________________________________	
	КонецЕсли;	
	//
	//
	Возврат Вых;
	//	
КонецФункции //Стр_(Методы="",Подметоды="",Вход,Парам1="",Парам2="",Позиции_Номера_Длины="",ДопВыход="")

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////





//Функция Колл_Выб(Вх,Заг="",Тек="",Сорт=Ложь,Отладка=Ложь)
//УНИВЕРСАЛЬНЫЙ ВЫБОР СТРОКИ ОБЩИХ КОЛЛЕКЦИЙ 
//(выбор, или для отладки, в случаях, когда нежелательно включать режим "Отладка")
//
//ВХОД
//Вх   - любая общая коллекция
//Заг  - Заголовок (например: имя переменной с Коллекцией);
//Тек  - Для ТЗ -  может иметь тип("СтрокаТаблицыЗначений") или Тип("Число") - индекс строки
//       Для СЗ -  может иметь тип("ЭлементСпискаЗначений") или Тип("Число") - индекс элемента
//       Для Массива - может иметь Тип("Число") - индекс элемента массива
//       Для остальных - Может иметь Тип("КлючИЗначение") или другой тип (считаем Ключом) 
//Сорт - Только для Структуры или Соответствия. В случае "Истина" - сортировка выбора по Ключу.
//
//ВЫХОД
//Тек - Индекс для ТЗ,СЗ,Массива; номер строки п/п для остальных (начиная с нуля!)
//
//Возвращает выбранную строку входной коллекции
Функция Колл_Выб(Вх,Заг="",Тек="",Сорт=Ложь,Отладка=Ложь) Экспорт
	Перем Т0,Т,Т1,Сч,ТекСтр,ТЗ,ТЗС,З,Стр,Ин;
	//
	Т=ТипЗнч(Вх); Т1=ТипЗнч(Тек); 
	Т0=?(Т=Тип("ТаблицаЗначений"),1,?(Т=Тип("СписокЗначений"),2,?(Т=Тип("Структура"),3,?(Т=Тип("Соответствие"),4,?(Т=Тип("Массив"),5,0)))));	
	Если Т0=0 тогда 
		Если Отладка=Истина тогда Сообщить("Процедура ""Колл_Выг(Вх,"""+Заг+""")"". ТипЗнч(Вх)=("+Т+"). Просмотр-Выбор невозможен!"); КонецЕсли;
		Возврат Тек; 
	КонецЕсли;	 
	Т1=?(Тек="",0,?(Т1=Тип("СтрокаТаблицыЗначений"),1,?(Т1=Тип("ЭлементСпискаЗначений"),2,?(Т1=Тип("КлючИЗначение"),3,?(Т1=Тип("Число"),4,5)))));	
	Если      Т0=1 тогда //ТаблицаЗначений. Работаем со ссылкой
		ТекСтр=?(Т1=1,Тек,?(Т1=4,Вх[Макс(Мин(Вх.Количество()-1,Тек),0)],""));  Ин=?(ТекСтр="",". "," ["+Вх.Индекс(ТекСтр)+"]. "); З=""+Т+"("+Вх.Количество()+")"+Ин+Заг;
		Если ТекСтр="" тогда Стр=Вх.ВыбратьСтроку(З); иначе Стр=Вх.ВыбратьСтроку(З,ТекСтр); КонецеСЛИ;
		Тек=неопределено; Если ТипЗнч(Стр)=Тип("СтрокаТаблицыЗначений") тогда Тек=Вх.Индекс(Стр); КонецЕсли;
		Возврат Стр;	
	ИначеЕсли Т0=2 тогда //СписокЗначений. Работаем со ссылкой
		ТекСтр=?(Т1=2,Тек,?(Т1=4,Вх[Макс(Мин(Вх.Количество()-1,Тек),0)],""));  Ин=?(ТекСтр="",". "," ["+Вх.Индекс(ТекСтр)+"]. "); З=""+Т+"("+Вх.Количество()+")"+Ин+Заг;
		Если ТекСтр="" тогда Стр=Вх.ВыбратьЭлемент(З); иначе Стр=Вх.ВыбратьЭлемент(З,ТекСтр); КонецЕсли;
		Тек=неопределено; Если ТипЗнч(Стр)=Тип("ЭлементСпискаЗначений") тогда Тек=Вх.Индекс(Стр); КонецЕсли;
		Возврат Стр;
	Иначе                //Структура,Соответствие,Массив. Перегружаем в ТЗ
		ТЗ=Новый ТаблицаЗначений; Сч=-1; ТекСтр=""; 
		ТЗ.Колонки.Добавить(?(Т0=5,"Инд","Ключ")); ТЗ.Колонки.Добавить("Значение"); ТЗ.Колонки.Добавить("Эл",,,1);
		Для Каждого Стр из Вх цикл ТЗС=Тз.Добавить(); ТЗС.Эл=Стр; Сч=Сч+1; 
			Если Т0=5 тогда ТЗС.Инд=Сч; ТЗС.Значение=Стр; Если (Т1=4) и (Сч=Тек) тогда ТекСтр=ТЗС; КонецЕсли;
			Иначе ТЗС.Ключ=Стр.Ключ; ТЗС.Значение=Стр.Значение; Если ((Т1=3) и (Стр=Тек)) или ((Т1>3) и (Стр.Ключ=Тек)) тогда ТекСтр=ТЗС; КонецЕсли;
			КонецЕсли;	
		КонецЦикла;
		//
		Если Сорт=Истина тогда ТЗ.Сортировать(?(Т0=5,"Ин","Ключ")); конецЕсли;
		//
		Ин=?(ТекСтр="",". "," ["+ТЗ.Индекс(ТекСтр)+"]. "); З=""+Т+"("+ТЗ.Количество()+")"+Ин+Заг; 
		Если ТекСтр="" тогда Стр=ТЗ.ВыбратьСтроку(З); иначе Стр=ТЗ.ВыбратьСтроку(З,ТекСтр); КонецеСЛИ;
		Если ТипЗнч(Стр)<>Тип("СтрокаТаблицыЗначений") тогда Тек=Неопределено; Стр=Тек; иначе Тек=ТЗ.Индекс(Стр); Стр=Стр.Эл; КонецЕсли;
		Возврат Стр;	
	КонецЕсли;
	Возврат Тек; 	
КонецФункции //Кол_Выб(Вх,Заг="")


