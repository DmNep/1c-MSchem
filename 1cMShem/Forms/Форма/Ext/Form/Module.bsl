
// На будущее:
// Сделать отображение функций вместе с параметрами
// При открытие формы - текст поле по умолчанию
// Сделать обработку ";", когда несколько строк кода в одной строке без символа переноса  
// Обработка ситуации, когда параметры функции указываются на в одну строку, а в ситолбик с переносом строки
// Обработать в Возврате вызов другой функции  
// Сделать на форме интерпритатор текста модуля (Сворачивать процедуры и функции, подсветка синтаксиса)
// Сделать на форме настройки  
// Сделать графическое обозначение обработчиков Команд и Элементов. Например для: "Процедура СформироватьСхему(Команда)" отобразить, картинку команды в шапке. 
// Переделать таблицу значение ТЗОбозначения из Функция СоздатьСхемуPlantUML на структуру
// Сделать настройку заголовка схемы
// Вставить начальный комментарий в схему кем, когда и на чем создана
// Обозначить каждый модуль схемы комментариями, чтобы схема была более читабельной
// Сделать отображение схемы интерактивной, при наведении на элемент - показывалась нужная процедура или функция в тексте (смена технологии отображения?) 
// При создании схемы на классах найти возможность дать имена методам вызова. Пример "class12" 
// Сделать возможность сохренения настроек в хранилище настроек и файл 
// Сделать остальные виды схемы card и rectangle  
// Сделать обработку ошибок
// Переделать настройки со строковых полей на список выбора, например Объект.ТипСтрелкиВозврата
// Произвести рефакторинг кода. Искать по комментарию "Переделать"
// Отображать на схеме если функция экспортная (надпись, картинка?)
// Разметить области в модуле 
// Подписать что делают настройки
// Переделать систему дробления текста модуля в массив с символа Символы.СП на ";"
// Сделать кнопки предварительного просмотра, печати и сохранения схемы
// Сделать поле с выводом схемы и кнопками для её сохранения +- 
// Добавить всех интерпритацию контекстов, например &НаСервереБезКонтекста 
// Создание ректанглов контекста вынести в отдельную функцию
// Отработать наличие ректанглов только на клиенте и тлько на сервере 
// Сделать определение внешних процедур и функций из других модулей
// Сделать обработку когда "//" находится в кавычках и является частью строковых данных
// Создание и завершение контекстных ректанглов вынести в отдельные функции
// Оптимизировать скорость работы
// Сделать едва заметную подпись на схеме с названием и версией обработки + дата формирования
// Блоки class сделать раздельные связи от методов класса (Вначале вызова вставить номер строки). Готово.
// Сделать интерпиретацию методов БСП
// Сделать интерпиретацию экспортных процедур функций конфигрурации под которой запускается обработка  

&НаСервере
Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)
	
	// Переделать на реквизиты формы
	// Заполняем первоначальные настройки
	Объект.ТипСтрелкиСвязи = "bold";
	Объект.ТипСтрелкиВозврата = "dashed";
	Объект.ОтображатьКонтекст = Ложь;
	Объект.ТолщинаСтрелкиСвязи = 2;
	Объект.ТолщинаСтрелкиВозврата = 1;
	Объект.ЦветСтрелкиСвязи = "#Blue"; 
	Объект.ЦветСтрелкиВозврата = "#Red";
	Объект.ТипСвязи = "skinparam linetype ortho"; 
	Объект.ТипСхемы = "left to right direction";
	Объект.РастояниеМеждуБлоками = 50;
	Объект.СокращатьДлиннуСтрок = Истина;
	Объект.ДлиннаСтрок = 100;
	объект.ВидБлоков = "class";
	//объект.ВидБлоков = "card"; 
	Объект.ВыделятьПиФЖирным = Истина;
	
	// Настройки соединения с сервером
	СерверРендеринга = "www.plantuml.com";
	РесурсСервера = "/plantuml/png/";
	ТаймаутСоединения = 20000;
	
КонецПроцедуры

&НаКлиенте
Процедура СформироватьСхему(Команда)
	
	Если Не ЗначениеЗаполнено(Объект.ТекстМодуля) Тогда
		Сообщить("Заполните текст модуля");
		Возврат;
	КонецЕсли;
	СформироватьТЗПроцедурИФункций();
	
КонецПроцедуры

Процедура СформироватьТЗПроцедурИФункций()
	
	Текст = Объект.ТекстМодуля;	
	
	ТЗПроцедурыИФункции = СобратьПроцедурыИФункции(Текст);
	ТЗСвязи = СоздатьСвязи(ТЗПроцедурыИФункции);
	
	СхемаPlantUML = СоздатьСхемуPlantUML(ТЗСвязи, ТЗПроцедурыИФункции);
	
	СгенерироватьНаСервере(СхемаPlantUML);
	
КонецПроцедуры

&НаСервере
Процедура СгенерироватьНаСервере(СхемаPlantUML)
	
	Результат = СгенерированноеИзображение(СхемаPlantUML, СерверРендеринга, РесурсСервера, ТаймаутСоединения);
	Если ЗначениеЗаполнено(Результат.АдресИзображения) Тогда
		РезультатОбработки = Результат.АдресИзображения;
	КонецЕсли; 
	
КонецПроцедуры  

Функция СгенерированноеИзображение(Данные, пСерверРендеринга, пРесурсСервера, пТаймаутСоединения) Экспорт
	
	ДвоичныеДанныеСтроки = ПолучитьДвоичныеДанныеИзСтроки(Данные);	
	СжатыеДанные = СжатыеДанные(ДвоичныеДанныеСтроки);	
	Base64Строка = Base64Строка(СжатыеДанные);     
	ФорматPlantUML = ФорматPlantUML(Base64Строка);  
	Соединение = Новый HTTPСоединение(пСерверРендеринга, , , , , пТаймаутСоединения);
	ТекстЗапроса = пРесурсСервера + ФорматPlantUML;
	Запрос = Новый HTTPЗапрос(ТекстЗапроса);
	Ответ = Соединение.Получить(Запрос);
	// ответ  не анализируется, дописать его анализ
	ДвоичныеДанныеКартинки = Ответ.ПолучитьТелоКакДвоичныеДанные();
	Результат = Новый Структура;
	Результат.Вставить("ОтветСервера", Ответ);
	Результат.Вставить("АдресИзображения", ПоместитьВоВременноеХранилище(ДвоичныеДанныеКартинки));
	Возврат Результат;
	
КонецФункции 

Функция СжатыеДанные(Данные) 
	
	ЧтениеДанных = Новый ЧтениеДанных(ЗаписатьZip(Данные));
	
	НачальноеСмещение = 14;
	ЧтениеДанных.Пропустить(НачальноеСмещение);
	CRC32 = ЧтениеДанных.ПрочитатьЦелое32();
	
	РазмерСжатыхДанных = ЧтениеДанных.ПрочитатьЦелое32();
	РазмерИсходныхДанных = ЧтениеДанных.ПрочитатьЦелое32();
	
	РазмерИмениФайла = ЧтениеДанных.ПрочитатьЦелое16();
	РазмерДополнительногоПоля = ЧтениеДанных.ПрочитатьЦелое16();
	ЧтениеДанных.Пропустить(РазмерИмениФайла + РазмерДополнительногоПоля);
	
	ПотокGZip = Новый ПотокВПамяти;
	ЗаписьДанных = Новый ЗаписьДанных(ПотокGZip);
	ЧтениеДанных.КопироватьВ(ЗаписьДанных, РазмерСжатыхДанных);
	
	Возврат ПотокGZip.ЗакрытьИПолучитьДвоичныеДанные();
	
КонецФункции 

Функция ФорматPlantUML(Данные)
	Результат = "";
	СтрокаИскомая	  = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	СтрокаПодстановки = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_"; 
	Для Счетчик = 0 По СтрДлина(Данные) - 1 Цикл     
		ТекСимвол = Сред(Данные, счетчик + 1, 1);
		Поз = СтрНайти(СтрокаИскомая, ТекСимвол); 
		Если ТекСимвол = Символы.ПС ИЛИ ТекСимвол = Символы.ВК Тогда
			Продолжить;
		КонецЕсли;
		Если Поз > 0  Тогда
			Результат = Результат + Сред(СтрокаПодстановки, Поз, 1);
		Иначе
			Результат = Результат + ТекСимвол; 
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

Функция ЗаписатьZip(Данные)
	
	#Если МобильноеПриложениеСервер Тогда
		ВызватьИсключение(НСтр("ru = 'Работа с Zip-файлами в мобильной платформе не поддерживается'"));
	#Иначе
		ВременныйФайл = ПолучитьИмяВременногоФайла(".bin");
		Данные.Записать(ВременныйФайл);
		ПотокZip = Новый ПотокВПамяти;
		ЗаписьZip = Новый ЗаписьZipФайла(ПотокZip);
		ЗаписьZip.Добавить(ВременныйФайл);
		ЗаписьZip.Записать();
		УдалитьФайлы(ВременныйФайл);
		
		Возврат ПотокZip.ЗакрытьИПолучитьДвоичныеДанные();
	#КонецЕсли
	
КонецФункции

//Функция Стр_ВМассив(ВходСтр,Разделитель="",НачНомВхождения=1,КонНомВхождения=10000000,Справа=Ложь,БезРегистра=Ложь)
//Возвращает массив с фрагментами строки
//между (НачНомВхождения) и (КонНомВхождения) разделителя (Разделитель);
//поиск разделителя возможен и справа (если Справа=Истина); 
//возможен поиск без учета регистра (если Безрегистра=Истина).
Функция Стр_ВМассив(ВходСтр,Разделитель="", НачНомВхождения=1, КонНомВхождения=10000000, Справа=Ложь, БезРегистра=Ложь) Экспорт
	
	СтрФрагменты  = Стр_Фрагменты(ВходСтр,Разделитель,Неопределено,НачНомВхождения,КонНомВхождения,Справа,БезРегистра,"М");
	Возврат СтрФрагменты;
	
КонецФункции //Стр_ЗаменитьКусок(ВходСтр,Разделитель="",СтрВставки="",НачНомВхождения=1,КонНомВхождения=10000000,Справа=Ложь,БезРегистра=Ложь,Масс="")

//Функция Стр_Фрагменты(Вход,Разделитель="",ЗаменаКуска=Неопределено,НачНомВх=1,КонНомВх=10000000,Справа=Ложь,БезРегистра=Ложь,ТипВых="C",УрРазд=1)
//Работа с фрагментами строки между разделителями (СтрПоиска)
//с (НачНомВх) по (КонНомВх) их вхождения. 
//
//По умолчанию возвращает "кусок" строки (ТиВых="С").
//
//Поиск возможен как слева, так и справа (если Справа=Истина); 
//
//Возможен поиск без учета регистра (если Безрегистра=Истина).
//
//Если определен параметр (ЗаменаКуска) - возвращает
//исходную строку с заменённым куском.
//
//Если (ТипВых="С")- возвращает Строку ("Кусок").
//Если (ТипВых="М")- возвращает Массив фрагментов.
//Если (ТипВых="Т")- возвращает Таблицу значений с колонками:
//  "Фр"  - фрагмент строки между разделителями или разделитель.
//  "Ур"  - номер группировки (0 - для фрагмента; (УрРазд) - для разделителя)
//  "КГ"  - количество групп символов (1, нужна для свёртки); 
//  "Поз" - позиция начала фрагмента/разделителя  в исходной строке;
//  "КС"  - количество символов в группе (длина фрагмента/разделителя);
//  Собственно, в первой колонке - это входная строка 
//  в "разобранном" виде!
//
Функция Стр_Фрагменты(Вход,Разделитель="",ЗаменаКуска=Неопределено,НачНомВх=1,КонНомВх=10000000,Справа=Ложь,БезРегистра=Ложь,ТипВых="C",УрРазд=1) Экспорт 
	
	Замена=(ТипЗнч(ЗаменаКуска)=Тип("Строка")); Нач=НачНомВх; Кон=КонНомВх;
	//
	Если ТипВых="С" тогда Стр1=""; Стр2=""; Стр3="";
	ИначеЕсли ТипВых="М" тогда 	Мас1=Новый Массив; Мас2=Новый Массив; Мас3=Новый Массив; 
	ИначеЕсли ТипВых="Т" тогда ТЗ1=Новый ТаблицаЗначений; КолТЗ=ТЗ1.Колонки; 
		КолТЗ.Добавить("Фр",,"Фрагмент"); 
		КолТЗ.Добавить("Ур",,"Уровень"); 
		КолТЗ.Добавить("КГ",,"Кол.Групп"); 
		КолТЗ.Добавить("Поз",,"Позиция"); 
		КолТЗ.Добавить("КС",,"Кол.Символов"); 
		ТЗ2=ТЗ1.Скопировать(); 
		ТЗ3=ТЗ1.Скопировать();
	КонецЕсли;
	//
	Если (Кон<Нач) или (Вход="") тогда Возврат ?(ТипВых="С","",?(ТипВых="М",Мас2,ТЗ2)) КонецЕсли;
	//
	Если БезРегистра тогда ВыхВ=ВРег(Вход);
		Пар1=ВРег(Разделитель); 
	иначе ВыхВ=Вход; 
		Пар1=Разделитель; 
	КонецЕсли;
	П=0; 
	Р2=""; 
	ПСлед=Неопределено; 
	Ном=0; 
	НачФ=0; 
	ДлФ=0; 
	ДлР=СтрДлина(Разделитель);
	//
	
	Для Сч=1 по 1000000 цикл П0=П; 
		П=ПСлед;
		П=Стр_НайтиВх(ВыхВ,Пар1,Справа,П,ПСлед,Начф,ДлФ); 
		Если НачФ=0 Тогда Прервать; 
		КонецЕсли; 
		Ном=Ном+1; 
		Фр=Сред(Вход,НачФ,ДлФ); 
		Р=?(П=0,"",Сред(Вход,П,ДлР));
		//
		Если Ном<=Нач тогда //до начального вхождения
			Если Замена тогда 
				Если ТипВых="С" тогда Стр1=?(Справа, Р+Фр+Стр1, Стр1+Фр+Р);                                           //Строка
				ИначеЕсли ТипВых="М" тогда 
					Если Справа тогда 
						Мас1.Вставить(0,Фр); 
					иначе Мас1.Добавить(Фр); 
					КонецЕсли; //Массив
				Иначе                                                                                                 //Таблица
					Если Фр<>"" тогда 
						Если Справа тогда  
							СтрТЗ=ТЗ1.Вставить(0); 
						иначе СтрТЗ=ТЗ1.Добавить(); 
						КонецЕсли;   
						СтрТЗ.Фр=Фр; 
						СтрТЗ.Ур=0; 
						СтрТЗ.КГ=1; 
						СтрТЗ.КС=ДлФ;
						СтрТЗ.Поз=НачФ;
					КонецЕсли;
					Если Р<>"" тогда 
						Если Справа тогда  
							СтрТЗ=ТЗ1.Вставить(0); 
						иначе СтрТЗ=ТЗ1.Добавить(); 
						КонецЕсли;   
						СтрТЗ.Фр=Р; 
						СтрТЗ.Ур=УрРазд;
						СтрТЗ.КГ=1; 
						СтрТЗ.КС=ДлР;
						СтрТЗ.Поз=П;
					КонецЕсли;		
				КонецЕсли;
			КонецЕсли;				
		ИначеЕсли Ном<=Кон 
			тогда РР=?(Ном<Кон,Р,""); 
			Р2=?(Ном=Кон,Р,Р2); //между нач и кон . вхождением
			Если не Замена тогда 
				Если ТипВых="С" тогда
					Стр2=?(Справа, РР+Фр+Стр2, Стр2+Фр+РР);                                         //Строка
				ИначеЕсли ТипВых="М" тогда
					Если Справа тогда Мас2.Вставить(0,Фр);
					иначе Мас2.Добавить(Фр); 
					КонецЕсли; //Массив
				Иначе                                                                                                 //Таблица
					Если Фр<>"" тогда 
						Если Справа тогда 
							СтрТЗ=ТЗ2.Вставить(0);
						иначе СтрТЗ=ТЗ2.Добавить();
						КонецЕсли;   
						СтрТЗ.Фр=Фр; 
						СтрТЗ.Ур=0;
						СтрТЗ.КГ=1; 
						СтрТЗ.КС=ДлФ; 
						СтрТЗ.Поз=НачФ;
					КонецЕсли;
					Если РР<>"" тогда 
						Если Справа тогда  СтрТЗ=ТЗ2.Вставить(0); 
						иначе СтрТЗ=ТЗ2.Добавить();
						КонецЕсли;   
						СтрТЗ.Фр=РР; 
						СтрТЗ.Ур=УрРазд; 
						СтрТЗ.КГ=1; СтрТЗ.КС=ДлР; 
						СтрТЗ.Поз=П;
					КонецЕсли;		
				КонецЕсли;		
			КонецЕсли;
		Иначе РР=?(Ном=(Кон+1),Р2,""); //после конечного вхождения
			Если Замена тогда 
				Если ТипВых="С" тогда 
					Стр3=?(Справа, Р+Фр+Стр3+РР, РР+Стр3+Фр+Р);                                     //Строка
				ИначеЕсли ТипВых="М" тогда 
					Если Справа тогда
						Мас3.Вставить(0,Фр);
					иначе Мас3.Добавить(Фр);
					КонецЕсли; //Массив
				Иначе                                                                                                 //Таблица
					Если Фр<>"" тогда 
						Если Справа тогда  
							СтрТЗ=ТЗ3.Вставить(0);
						иначе СтрТЗ=ТЗ3.Добавить();
						КонецЕсли;   
						СтрТЗ.Фр=Фр;
						СтрТЗ.Ур=0;
						СтрТЗ.КГ=1;
						СтрТЗ.КС=ДлФ;
						СтрТЗ.Поз=НачФ;
					КонецЕсли;
					Если РР<>"" тогда 
						Если Справа тогда 
							СтрТЗ=ТЗ3.Вставить(0); 
						иначе СтрТЗ=ТЗ3.Добавить(); 
						КонецЕсли;   
						СтрТЗ.Фр=РР; 
						СтрТЗ.Ур=УрРазд;
						СтрТЗ.КГ=1; 
						СтрТЗ.КС=ДлР;
						СтрТЗ.Поз=П;
					КонецЕсли;		
				КонецЕсли;	
			КонецЕсли;
		КонецЕсли;				
		//
		Если (не Замена) и (Ном=Кон) тогда Прервать; КонецЕсли; //Получили кусок, для нас достаточно
		//	
	КонецЦикла;		
	//
	//ЗАМЕНА КУСКА
	Если Не Замена тогда 
		Вых=Стр2; //Кусок строки
		Если ТипВых="С" тогда
			Вых=Стр2
		ИначеЕсли ТипВых="М" тогда
			Вых=Мас2;
		Иначе Вых=ТЗ2;	
		КонецЕсли;	
	иначеЕсли Ном>=Кон тогда //Замена куска и после Кон.
		Если ТипВых="С" тогда 
			Вых=?(Справа,Стр3+ЗаменаКуска+Стр1,Стр1+ЗаменаКуска+Стр3);
		ИначеЕсли ТипВых="М" тогда		
			Если Справа тогда
				Вых=Мас3; 
				Вых.Добавить(ЗаменаКуска); 
				Для каждого э из Мас1 цикл 
					Вых.Добавить(Э);
				КонецЦикла;
			Иначе Вых=Мас1;
				Вых.Добавить(ЗаменаКуска);
				Для каждого э из Мас3 цикл 
					Вых.Добавить(Э);
				КонецЦикла;
			КонецЕсли;		
		Иначе	
			Если Справа тогда 
				Вых=ТЗ3; 
				СтрТЗ=Вых.Добавить(); //(ЗаменаКуска); 
				Для каждого э из ТЗ1 цикл 
					СтрТ=Вых.Добавить(); 
					СтрТ=Э;
				КонецЦикла;
			Иначе Вых=ТЗ1; 
				СтрТЗ=Вых.Добавить(); //(ЗаменаКуска); 
				Для каждого э из ТЗ3 цикл 
					СтрТ=Вых.Добавить(); 
					Стрт=Э; КонецЦикла;
			КонецЕсли;		
		КонецЕсли;	
	Иначе  
		Если ТипВых="C" тогда Вых=Стр1;
		ИначеЕсли ТипВых="М" тогда Вых=Мас1;
		Иначе Вых=ТЗ1;	
		КонецЕсли;	
	КонецЕсли;	
	//	
	МаксНом=Ном;
	
	Возврат Вых; 
	
КонецФункции //Стр_Фрагменты(Метод="К",ВходСтр,Разделитель="",ЗаменаКуска="",НачНомВхождения=1,КонНомВхождения=10000000,Справа=Ложь,БезРегистра=Ложь,Масс="")

//Функция Стр_НайтиВх(ВходСтр,Разделитель,Справа=Ложь,НачПозПоиска=Неопределено,ПозСледПоиска=0,ПозНачФрагмента=0,ДлинаФрагмента=0)
//Возвращает позицию следующего найденного разделителя.
//Аналог Найти(...). Но возможен поиск слева и справа 
//и с указанной позиции
//ВХОД:
//  ВходСтрок     - строка, в которой ведется поиск Разделителя;
//  Разделитель   - группа символов, разделяющих фрагменты строки;
//  Справа=Ложь   - поиск производиться слева направо (иначе - наоборот)
//  НачПозПоиска  - позиция, с которой следует начинать поиск;
//ВЫХОД:
//  ПозСледПоиска   - вычисленная нач. позиция следующего поиска;
//  ПозНачФрагмента - нач.поз.фрагмента строки до найденного разделителя;
//  ДлинаФрагмента  - Длина фрагмента строки до найденного разделителя;
//
//
//
Функция Стр_НайтиВх(ВходСтр,Разделитель,Справа=Ложь,НачПозПоиска=Неопределено,ПозСледПоиска=0,ПозНачФрагмента=0,ДлинаФрагмента=0) Экспорт
	ДлРазд=СтрДлина(Разделитель);
	Дл=СтрДлина(ВходСтр);
	П=0; Раз=""; 
	ПозТек=?(НачПозПоиска<>Неопределено,НачПозПоиска,?(Справа,Дл,1)); //ПозНачФрагмента=ПозТек;
	Если ПозТек=0 тогда 
		СледПозПоиска=0; 
		ПозНачФрагмента=0; 
		ДлинаФрагмента=0;
		Возврат 0;
	КонецЕсли;
	Если Справа тогда 	//Ищем справа
		Для сч=-ПозТек по -1 Цикл 
			С=Сред(ВходСтр,-Сч,1); 
			Раз=С+Лев(Раз,ДлРазд-1); 
			Если СтрДлина(Раз)<ДлРазд тогда 
				Продолжить; 
			КонецЕсли;
			Если Раз=Разделитель тогда 
				П=-Сч;
				Прервать; 
			КонецЕсли;
		КонецЦикла;	
		ПозСледПоиска=?(П=0,0,П-1);
		ПозНачФрагмента=?(П=0,1,П+ДлРазд);		
		ДлинаФрагмента=ПозТек-ПозНачФрагмента+1; 	
	Иначе //Ищем слева	
		Для сч=ПозТек по Дл Цикл 
			С=Сред(ВходСтр,Сч,1);
			Раз=Прав(Раз,ДлРазд-1)+С; 
			Если СтрДлина(Раз)<ДлРазд тогда 
				Продолжить;
			КонецЕсли;
			Если Раз=Разделитель тогда 
				П=Сч-ДлРазд+1; 
				Прервать;
			КонецЕсли;
		КонецЦикла;	
		ПозСледПоиска=?(П=0,0,П+ДлРазд); 
		ПозСледПоиска=?(ПозСледПоиска>Дл,0,ПозСледПоиска);	
		ПозНачФрагмента=ПозТек; 
		ДлинаФрагмента=?(П=0,Дл-ПозТек+1,П-ПозТек);
	КонецЕсли;	
	Возврат П; 
	
КонецФункции //Стр_СледРазд(ВходСтр,Разд,ПозТек=0,Справа=Ложь)

Функция СтрСократить(Текст, Количество, Многострочная = Ложь) Экспорт
	
	ТекстМногострочный = МногострочнаяСтрока(Текст);
	Если ТекстМногострочный И НЕ Многострочная Тогда
		ПерваяСтрока = СтрПолучитьСтроку(Текст, 1);
		Результат = Сократить(ПерваяСтрока, Количество, Истина);
	Иначе
		Результат = Сократить(Текст, Количество);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции  

Функция МногострочнаяСтрока(Строка) Экспорт
	
	Возврат Булево(СтрНайти(Строка, Символы.ПС));
	
КонецФункции

Функция Сократить(Текст, Количество, ВсегдаДобавлятьЗавершение = Ложь)
	
	Завершение = "...";
	НормальнаяДлина = Количество - СтрДлина(Завершение);
	
	Длина = СтрДлина(Текст);
	Если Длина > НормальнаяДлина Тогда
		Результат = Лев(Текст, НормальнаяДлина) + Завершение;
	Иначе
		Результат = Текст;
		Если ВсегдаДобавлятьЗавершение Тогда
			Результат = Результат + Завершение;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

&НаСервере
Функция СобратьПроцедурыИФункции(Текст)
	
	//Собрать переменные
	
	//Текст в массив	
	КоличествоСимволов = СтрДлина(Текст);
	ТекстМассив = Стр_ВМассив(Текст, Символы.ПС, 1, КоличествоСимволов, Ложь, Ложь);   
	
	//Инициализировать ТЗ ПроцедурыИФункции
	КЧ = Новый КвалификаторыЧисла(10);
	КС = Новый КвалификаторыСтроки(0);
	Массив = Новый Массив;
	Массив.Добавить(Тип("Строка"));
	ОписаниеТиповС = Новый ОписаниеТипов(Массив, ,КС);
	Массив.Очистить();
	Массив.Добавить(Тип("Число"));
	ОписаниеТиповЧ = Новый ОписаниеТипов(Массив, , ,КЧ);		
	Массив.Очистить();
	ОписаниеТиповБ = Новый ОписаниеТипов("Булево");
	
	ТаблицаПиФ = Новый ТаблицаЗначений;
	ТаблицаПиФ.Колонки.Добавить("Наименование",   ОписаниеТиповС);
	ТаблицаПиФ.Колонки.Добавить("ЭтоФункция",     ОписаниеТиповБ);
	ТаблицаПиФ.Колонки.Добавить("КолвоПараметров",ОписаниеТиповЧ);
	ТаблицаПиФ.Колонки.Добавить("Экспортная",     ОписаниеТиповБ);
	ТаблицаПиФ.Колонки.Добавить("Возврат",        ОписаниеТиповС);
	ТаблицаПиФ.Колонки.Добавить("НомСтрВозврат",  ОписаниеТиповЧ);
	ТаблицаПиФ.Колонки.Добавить("Контекст",       ОписаниеТиповС);
	ТаблицаПиФ.Колонки.Добавить("СтрокаНачало",   ОписаниеТиповЧ);
	ТаблицаПиФ.Колонки.Добавить("СтрокаОкончание",ОписаниеТиповЧ);
	ТаблицаПиФ.Колонки.Добавить("ЭтоЭлемент",     ОписаниеТиповБ);
	ТаблицаПиФ.Колонки.Добавить("ЭтоКоманда",     ОписаниеТиповБ);
	ТаблицаПиФ.Колонки.Добавить("ТекстПиФ",       ОписаниеТиповС);
	
	ИндексПроцедурыИлиФункции = 0;	
	ИдетПроцедура = Ложь;
	ИдетФункция   = Ложь;
	Контекст = "";
	НомерСтроки = 0;
	
	Для Каждого Строка Из ТекстМассив Цикл
		
		НомерСтроки = НомерСтроки + 1;
		Если Не ЗначениеЗаполнено(Строка) Тогда
			Продолжить;
		КонецЕсли;
		СтрокаБезПРобелов = СокрЛП(Строка);
		ДлиннаСтроки = СтрДлина(СтрокаБезПРобелов);
		//Пропустить комментарии
		Если Лев(СтрокаБезПРобелов, 2) = "//" Тогда
			Продолжить;	
		КонецЕсли;
		// Вырезаем комментарии, которые находятся в строке ЗА кодом.
		// Чтобы избежать коллизии. Например при поиске связей между
		// процедурами и функциями, которые находятся в комментарии
		// Доработать
		ПозицияКоммента = СтрНайти(Строка, "//");
		Если ЗначениеЗаполнено(ПозицияКоммента) Тогда
			Строка = Лев(Строка, ПозицияКоммента - 1) 
		КонецЕсли;
		
		
		Если Не ИдетПроцедура И Не ИдетФункция Тогда
			
			// Добавить всех контекстов, например &НаСервереБезКонтекста
			//Проверить на контекст
			Если Лев(СтрокаБезПРобелов, 1) = "&" Тогда
				Контекст = СтрокаБезПРобелов;
				Продолжить;
			КонецЕсли;
			
			//Проверить на процедуру или функцию
			Если Лев(СтрокаБезПРобелов, 9) = "Процедура" Тогда
				
				ИдетПроцедура = Истина;
				НовыяСтрокаПиФ = ТаблицаПиФ.Добавить();
				//Заполняем начальные данные процедуры
				//Устанавливаем курсор на начало наименования
				Наименование = СокрЛ(Прав(СтрокаБезПРобелов, ДлиннаСтроки - 9));	
				//Определяем пеозицию первой левой скобки
				ПозицияЛевойСкобки = СтрНайти(Наименование, "(");
				НовыяСтрокаПиФ.Наименование = СокрП(Лев(Наименование, ПозицияЛевойСкобки - 1));
				НовыяСтрокаПиФ.СтрокаНачало = НомерСтроки;
				//Заполнить количество параметров
				ПараметрыСтр = Прав(Наименование, (СтрДлина(Наименование) - ПозицияЛевойСкобки + 1));
				ПозицияПравойСкобки = СтрНайти(ПараметрыСтр, ")");
				ПараметрыСтр = Лев(ПараметрыСтр, ПозицияПравойСкобки);
				НовыяСтрокаПиФ.КолвоПараметров = СтрЧислоВхождений(ПараметрыСтр, ",") + 1;
				//Экспортная
				Если Прав(СтрокаБезПРобелов, 7) = "Экспорт" Тогда 
					НовыяСтрокаПиФ.Экспортная = Истина;		
				КонецЕсли;
				//Это Элемент 
				Если СтрНайти(СтрокаБезПРобелов, "(Элемент)") > 0 Тогда
					НовыяСтрокаПиФ.ЭтоЭлемент = Истина;
				КонецЕсли;
				//Это Кнопка
				Если СтрНайти(СтрокаБезПРобелов, "(Команда)") > 0 Тогда
					НовыяСтрокаПиФ.ЭтоКоманда = Истина;
				КонецЕсли;
				//Заполняем контекст 
				// Переделать с учетом всех контекстов
				Если ЗначениеЗаполнено(Контекст) Тогда
					НовыяСтрокаПиФ.Контекст = Контекст; 
				Иначе
					НовыяСтрокаПиФ.Контекст = "&НаСервере";
				КонецЕсли;
				НовыяСтрокаПиФ.ТекстПиФ = Строка; 
				
			ИначеЕсли Лев(СтрокаБезПРобелов, 7) = "Функция" Тогда
				
				ИдетФункция = Истина;
				НовыяСтрокаПиФ = ТаблицаПиФ.Добавить();
				
				//Задаём ТЗ возвратов
				КЧ = Новый КвалификаторыЧисла(10);
				КС = Новый КвалификаторыСтроки(0);
				Массив = Новый Массив;
				Массив.Добавить(Тип("Строка"));
				ОписаниеТиповС = Новый ОписаниеТипов(Массив, ,КС);
				Массив.Очистить();
				Массив.Добавить(Тип("Число"));
				ОписаниеТиповЧ = Новый ОписаниеТипов(Массив, , ,КЧ);		
				Массив.Очистить();
				ОписаниеТиповБ = Новый ОписаниеТипов("Булево");
				
				ТаблицаВозвратов = Новый ТаблицаЗначений;
				ТаблицаВозвратов.Колонки.Добавить("Возврат",     ОписаниеТиповС);
				ТаблицаВозвратов.Колонки.Добавить("НомерСтроки", ОписаниеТиповЧ);
				
				//Заполняем начальные данные функции 
				НовыяСтрокаПиФ.ЭтоФункция = Истина;
				//Устанавливаем курсор на начало наименования
				Наименование = СокрЛ(Прав(СтрокаБезПРобелов, ДлиннаСтроки - 7));	
				//Определяем пеозицию первой левой скобки
				ПозицияЛевойСкобки = СтрНайти(Наименование, "(");
				НовыяСтрокаПиФ.Наименование = СокрП(Лев(Наименование, ПозицияЛевойСкобки - 1));
				НовыяСтрокаПиФ.СтрокаНачало = НомерСтроки;
				//Заполнить количество параметров
				ПараметрыСтр = Прав(Наименование, (СтрДлина(Наименование) - ПозицияЛевойСкобки + 1));
				ПозицияПравойСкобки = СтрНайти(ПараметрыСтр, ")");
				ПараметрыСтр = Лев(ПараметрыСтр, ПозицияПравойСкобки);
				НовыяСтрокаПиФ.КолвоПараметров = СтрЧислоВхождений(ПараметрыСтр, ",") + 1;
				//Экспортная
				Если Прав(СтрокаБезПРобелов, 7) = "Экспорт" Тогда 
					НовыяСтрокаПиФ.Экспортная = Истина;		
				КонецЕсли;
				//Заполняем контекст
				Если ЗначениеЗаполнено(Контекст) Тогда
					НовыяСтрокаПиФ.Контекст = Контекст;
				Иначе
					НовыяСтрокаПиФ.Контекст = "&НаСервере";
				КонецЕсли;
				НовыяСтрокаПиФ.ТекстПиФ = Строка; 
				
			КонецЕсли;
			
		Иначе  //Если Не ИдетПроцедура И Не ИдетФункция Тогда
			
			Если ИдетПроцедура Тогда 
				
				// Добавляем строку в текст ПиФ
				НовыяСтрокаПиФ.ТекстПиФ = НовыяСтрокаПиФ.ТекстПиФ + Символы.ПС + Строка; 
				
				//Ищем конец процедуры
				Если Лев(СтрокаБезПРобелов, 14) = "КонецПроцедуры" Тогда 
					
					// Записать длинну процедуры в строках
					ИдетПроцедура = Ложь;
					НовыяСтрокаПиФ.СтрокаОкончание = НомерСтроки;
					//Сбрасываем контекст
					Контекст = ""; 
					
				КонецЕсли;
				
			КонецЕсли;
			
			Если ИдетФункция Тогда
				
				// Добавляем строку в текст ПиФ
				НовыяСтрокаПиФ.ТекстПиФ = НовыяСтрокаПиФ.ТекстПиФ + Символы.ПС + Строка; 
				
				//Ищем строки Возврат
				Если Лев(СтрокаБезПРобелов, 7) = "Возврат" Тогда
					НовыйВозврат = ТаблицаВозвратов.Добавить();
					НовыйВозврат.Возврат = СтрокаБезПРобелов;
					НовыйВозврат.НомерСтроки = СтрЧислоСтрок(НовыяСтрокаПиФ.ТекстПиФ);
				КонецЕсли;	
				
				//Ищем конец функции
				Если Лев(СтрокаБезПРобелов, 12) = "КонецФункции" Тогда
					
					// Записать длинну функцию в строках
					ИдетФункция = Ложь;
					НовыяСтрокаПиФ.СтрокаОкончание = НомерСтроки;
					// Выбрать из всех возвратов верный и записать его
					Если ТаблицаВозвратов.Количество() = 1 Тогда
						НовыяСтрокаПиФ.Возврат = ТаблицаВозвратов[0].Возврат;
						НовыяСтрокаПиФ.НомСтрВозврат = ТаблицаВозвратов[0].НомерСтроки;
					Иначе	
						
						Для Каждого ЭлементТЗ Из ТаблицаВозвратов Цикл 
							
							//Берём первый возврат без неопределдено - ПЕРЕДЕЛАТЬ
							Если СтрНайти(ЭлементТЗ.Возврат, "Неопределено") = 0 Тогда
								НовыяСтрокаПиФ.Возврат = ЭлементТЗ.Возврат;
								НовыяСтрокаПиФ.НомСтрВозврат = ЭлементТЗ.НомерСтроки;
							КонецЕсли;
							
						КонецЦикла;
						
					КонецЕсли;
					
					//Сбрасываем возвраты
					ТаблицаВозвратов.Очистить();
					//Сбрасываем контекст
					Контекст = "";
					
				КонецЕсли;
				
			КонецЕсли; 
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат ТаблицаПиФ;
	
	// Очищаем память
	// Сделать
	
КонецФункции

Функция СоздатьСвязи(ТЗПроцедурыИФункции) 
	
	// Преамбула
	//Наименование,   Строка
	//ЭтоФункция,     Булево
	//КолвоПараметров,Число
	//Экспортная,     Булево
	//Возврат,        Строка
	//Контекст,       Строка
	//СтрокаНачало,   Число
	//СтрокаОкончание,Число
	//ЭтоЭлемент,     Булево
	//ЭтоКоманда,     Булево              
	//ТекстПиФ,       Булево
	
	//Инициализировать ТЗСвязи
	КЧ = Новый КвалификаторыЧисла(10);
	КС = Новый КвалификаторыСтроки(0);
	Массив = Новый Массив;
	Массив.Добавить(Тип("Строка"));
	ОписаниеТиповС = Новый ОписаниеТипов(Массив, ,КС);
	Массив.Очистить();
	Массив.Добавить(Тип("Число"));
	ОписаниеТиповЧ = Новый ОписаниеТипов(Массив, , ,КЧ);		
	Массив.Очистить();
	ОписаниеТиповБ = Новый ОписаниеТипов("Булево");
	ТЗСвязи = Новый ТаблицаЗначений;
	ТЗСвязи.Колонки.Добавить("СвязьОт",           ОписаниеТиповС);
	ТЗСвязи.Колонки.Добавить("СвязьК",            ОписаниеТиповС);
	ТЗСвязи.Колонки.Добавить("ЦветСвязи",         ОписаниеТиповС);
	ТЗСвязи.Колонки.Добавить("ТипЛинииСвязи",     ОписаниеТиповС); 
	ТЗСвязи.Колонки.Добавить("ЭтоВозврат",        ОписаниеТиповБ); 
	ТЗСвязи.Колонки.Добавить("СтрокаВозврат",     ОписаниеТиповС); 
	ТЗСвязи.Колонки.Добавить("НомСтрВызоваОт",    ОписаниеТиповЧ); 
	ТЗСвязи.Колонки.Добавить("СтрокаВызоваОт",    ОписаниеТиповС); 
	ТЗСвязи.Колонки.Добавить("СокрСтрокаВызоваОт",ОписаниеТиповС); 
	ТЗСвязи.Колонки.Добавить("СвязьКФункции",     ОписаниеТиповБ); 
	
	ТЗПиФДляСвязей = ТЗПроцедурыИФункции.Скопировать(, "Наименование, ТекстПиФ, ЭтоФункция, Возврат");
	Для Каждого ЭлементОт Из ТЗПиФДляСвязей Цикл
		
		// Пропускаем первую строку
		// Избавляет от коллизии когда название одной функции входит в другую
		// Например в функцию "СтрСократить" входит функция "Сократить" 
		// А так же позволяет отслеживать рекурсивные вызовы
		ПерваяСтрока = СтрПолучитьСтроку(ЭлементОт.ТекстПиФ, 1);
		ЭлементОт.ТекстПиФ = СтрЗаменить(ЭлементОт.ТекстПиФ, ПерваяСтрока + Символы.ПС, "");
		
		//МассивСтрТекстПиФ = Стр_ВМассив(ЭлементОт.ТекстПиф, Символы.ПС, 0);
		
		Для Каждого ЭлементК Из ТЗПиФДляСвязей Цикл
			
			//Если ЭлементОт.Наименование = ЭлементК.Наименование Тогда
			//	Продолжить;
			//КонецЕсли;
			НачальнаяПозиция = 1;
			
			//МассивСтрПиФ = Стр_ВМассив(ЭлементОт.ТекстПиФ
			
			ЭлемТекстПиФ = ЭлементОт.ТекстПиФ;
			ТЗСвязи = РекурсивныйПоиск(ТЗСвязи, НачальнаяПозиция, ЭлемТекстПиФ, ЭлементОт, ЭлементК); 
			
		КонецЦикла;
		
	КонецЦикла;
	
	Возврат ТЗСвязи;
	
КонецФункции 

Функция РекурсивныйПоиск(ТЗСвязи, НачальнаяПозиция, ЭлемТекстПиФ, ЭлементОт, ЭлементК)
	
	ПозПервЗнака = 0;
	
	// Ищем связь
	ПозПервЗнака1  = СтрНайти(ЭлемТекстПиФ, " " + ЭлементК.Наименование + " (",,НачальнаяПозиция); // Избавляет от коллизии когда название одной функции входит в другую
	ПозПервЗнака2  = СтрНайти(ЭлемТекстПиФ, "=" + ЭлементК.Наименование + " (",,НачальнаяПозиция); // Например в функцию "СтрСократить" входит функция "Сократить"
	ПозПервЗнака3  = СтрНайти(ЭлемТекстПиФ, "." + ЭлементК.Наименование + " (",,НачальнаяПозиция); //
	ПозПервЗнака4  = СтрНайти(ЭлемТекстПиФ, "(" + ЭлементК.Наименование + " (",,НачальнаяПозиция); //
	ПозПервЗнака5  = СтрНайти(ЭлемТекстПиФ, "," + ЭлементК.Наименование + " (",,НачальнаяПозиция); //   переделать на более изящный вариант
	ПозПервЗнака6  = СтрНайти(ЭлемТекстПиФ, ";" + ЭлементК.Наименование + " (",,НачальнаяПозиция); //
	ПозПервЗнака7  = СтрНайти(ЭлемТекстПиФ, "+" + ЭлементК.Наименование + " (",,НачальнаяПозиция); //
	ПозПервЗнака8  = СтрНайти(ЭлемТекстПиФ, "-" + ЭлементК.Наименование + " (",,НачальнаяПозиция); //
	ПозПервЗнака9  = СтрНайти(ЭлемТекстПиФ, "/" + ЭлементК.Наименование + " (",,НачальнаяПозиция); //
	ПозПервЗнака0  = СтрНайти(ЭлемТекстПиФ, "*" + ЭлементК.Наименование + " (",,НачальнаяПозиция); //
	ПозПервЗнака11 = СтрНайти(ЭлемТекстПиФ, " " + ЭлементК.Наименование + "(",,НачальнаяПозиция); // 
	ПозПервЗнака12 = СтрНайти(ЭлемТекстПиФ, "=" + ЭлементК.Наименование + "(",,НачальнаяПозиция); // 
	ПозПервЗнака13 = СтрНайти(ЭлемТекстПиФ, "." + ЭлементК.Наименование + "(",,НачальнаяПозиция); //
	ПозПервЗнака14 = СтрНайти(ЭлемТекстПиФ, "(" + ЭлементК.Наименование + "(",,НачальнаяПозиция); //
	ПозПервЗнака15 = СтрНайти(ЭлемТекстПиФ, "," + ЭлементК.Наименование + "(",,НачальнаяПозиция); // 
	ПозПервЗнака16 = СтрНайти(ЭлемТекстПиФ, ";" + ЭлементК.Наименование + "(",,НачальнаяПозиция); //
	ПозПервЗнака17 = СтрНайти(ЭлемТекстПиФ, "+" + ЭлементК.Наименование + "(",,НачальнаяПозиция); //
	ПозПервЗнака18 = СтрНайти(ЭлемТекстПиФ, "-" + ЭлементК.Наименование + "(",,НачальнаяПозиция); //
	ПозПервЗнака19 = СтрНайти(ЭлемТекстПиФ, "/" + ЭлементК.Наименование + "(",,НачальнаяПозиция); //
	ПозПервЗнака10 = СтрНайти(ЭлемТекстПиФ, "*" + ЭлементК.Наименование + "(",,НачальнаяПозиция); //
	ПозПервЗнака20 = СтрНайти(ЭлемТекстПиФ, "" + Символы.Таб + ЭлементК.Наименование + "(",,НачальнаяПозиция); //
	ПозПервЗнака21 = СтрНайти(ЭлемТекстПиФ, "" + Символы.Таб + ЭлементК.Наименование + " (",,НачальнаяПозиция); //
	Если ЗначениеЗаполнено(ПозПервЗнака1) Тогда
		ПозПервЗнака = ПозПервЗнака1; 
	ИначеЕсли ЗначениеЗаполнено(ПозПервЗнака2) Тогда	
		ПозПервЗнака = ПозПервЗнака2;
	ИначеЕсли ЗначениеЗаполнено(ПозПервЗнака3) Тогда	
		ПозПервЗнака = ПозПервЗнака3;
	ИначеЕсли ЗначениеЗаполнено(ПозПервЗнака4) Тогда	
		ПозПервЗнака = ПозПервЗнака4;
	ИначеЕсли ЗначениеЗаполнено(ПозПервЗнака5) Тогда	
		ПозПервЗнака = ПозПервЗнака5;
	ИначеЕсли ЗначениеЗаполнено(ПозПервЗнака6) Тогда	
		ПозПервЗнака = ПозПервЗнака6;
	ИначеЕсли ЗначениеЗаполнено(ПозПервЗнака7) Тогда	
		ПозПервЗнака = ПозПервЗнака7;
	ИначеЕсли ЗначениеЗаполнено(ПозПервЗнака8) Тогда	
		ПозПервЗнака = ПозПервЗнака8;
	ИначеЕсли ЗначениеЗаполнено(ПозПервЗнака9) Тогда	
		ПозПервЗнака = ПозПервЗнака9;
	ИначеЕсли ЗначениеЗаполнено(ПозПервЗнака0) Тогда	
		ПозПервЗнака = ПозПервЗнака0;
	ИначеЕсли ЗначениеЗаполнено(ПозПервЗнака11) Тогда
		ПозПервЗнака = ПозПервЗнака11; 
	ИначеЕсли ЗначениеЗаполнено(ПозПервЗнака12) Тогда	
		ПозПервЗнака = ПозПервЗнака12;
	ИначеЕсли ЗначениеЗаполнено(ПозПервЗнака13) Тогда	
		ПозПервЗнака = ПозПервЗнака13;
	ИначеЕсли ЗначениеЗаполнено(ПозПервЗнака14) Тогда	
		ПозПервЗнака = ПозПервЗнака14;
	ИначеЕсли ЗначениеЗаполнено(ПозПервЗнака15) Тогда	
		ПозПервЗнака = ПозПервЗнака15;
	ИначеЕсли ЗначениеЗаполнено(ПозПервЗнака16) Тогда	
		ПозПервЗнака = ПозПервЗнака16;
	ИначеЕсли ЗначениеЗаполнено(ПозПервЗнака17) Тогда	
		ПозПервЗнака = ПозПервЗнака17;
	ИначеЕсли ЗначениеЗаполнено(ПозПервЗнака18) Тогда	
		ПозПервЗнака = ПозПервЗнака18;
	ИначеЕсли ЗначениеЗаполнено(ПозПервЗнака19) Тогда	
		ПозПервЗнака = ПозПервЗнака19;
	ИначеЕсли ЗначениеЗаполнено(ПозПервЗнака10) Тогда	
		ПозПервЗнака = ПозПервЗнака10;
	ИначеЕсли ЗначениеЗаполнено(ПозПервЗнака20) Тогда	
		ПозПервЗнака = ПозПервЗнака20;
	ИначеЕсли ЗначениеЗаполнено(ПозПервЗнака21) Тогда	
		ПозПервЗнака = ПозПервЗнака21;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ПозПервЗнака) Тогда 
		
		СтрДляПоиска = Лев(ЭлемТекстПиФ, ПозПервЗнака);
		НомСтрВызов  = СтрЧислоСтрок(СтрДляПоиска); 
		
		// Формируем связь
		НоваяСвязь = ТЗСвязи.Добавить();
		НоваяСвязь.СвязьОт = ЭлементОт.Наименование;
		НоваяСвязь.СвязьК  = ЭлементК.Наименование;
		НоваяСвязь.НомСтрВызоваОт = НомСтрВызов;
		Если ЭлементК.ЭтоФункция Тогда
			СтрокаВызова = СокрЛП(СтрПолучитьСтроку(ЭлемТекстПиФ, НомСтрВызов)); 
			СокрСтрокаВызова = СокрЛП(Лев(СтрокаВызова, СтрНайти(СтрокаВызова, "=") - 1));
			НоваяСвязь.СокрСтрокаВызоваОт = "" + НомСтрВызов + "_" + СокрСтрокаВызова;
			НоваяСвязь.СтрокаВызоваОт = "" + НомСтрВызов + "_" + СтрокаВызова;
			НоваяСвязь.СвязьКФункции = Истина;
		Иначе	
			НоваяСвязь.СокрСтрокаВызоваОт = "" + НомСтрВызов + "_" + ЭлементК.Наименование;
			НоваяСвязь.СтрокаВызоваОт = "" + НомСтрВызов + "_" + ЭлементК.Наименование+"()";
		КонецЕсли;
		
		// Добавить тип связи и цвет
		
		// Формируем возврат
		Если ЭлементК.ЭтоФункция Тогда 
			
			НоваяСвязь = ТЗСвязи.Добавить();
			НоваяСвязь.СвязьОт = ЭлементК.Наименование;
			НоваяСвязь.СвязьК  = ЭлементОт.Наименование;
			НоваяСвязь.ЭтоВозврат = Истина;
			НоваяСвязь.СтрокаВозврат = ЭлементК.Возврат;
			НоваяСвязь.СокрСтрокаВызоваОт = "Возврат";	
			// Добавить тип связи и цвет
			
		КонецЕсли;
		
		ТЗСвязи = РекурсивныйПоиск(ТЗСвязи, ПозПервЗнака + СтрДлина(ЭлементК.Наименование) + 1 , ЭлемТекстПиФ, ЭлементОт, ЭлементК);
		
	КонецЕсли;	
	
	Возврат ТЗСвязи;
	
КонецФункции

Функция СоздатьСхемуPlantUML(ТЗСвязи, ТЗПроцедурыИФункции)
	
	// Преамбула
	//
	//    ТЗПроцедурыИФункции   |         ТЗСвязи
	//  ----------------------- | -----------------------
	//  Колонка      |  Тип     |   Колонка         |  Тип
	// Наименование,   Строка   |  СвязьОт,           Строка
	// ЭтоФункция,     Булево   |  СвязьК,            Строка
	// КолвоПараметров,Число    |  ЦветСвязи,         Строка
	// Экспортная,     Булево   |  ТипЛинииСвязи,     Строка
	// Возврат,        Строка   |  ЭтоВозврат,        Булево
	// Контекст,       Строка   |  СтрокаВозврат,     Строка
	// СтрокаНачало,   Число    |  НомСтрВызоваОт,    Число
	// СтрокаОкончание,Число    |  СтрокаВызоваОт,    Строка
	// ЭтоЭлемент,     Булево   |  СокрСтрокаВызоваОт,Строка
	// ЭтоКоманда,     Булево   |  СвязьКФункции,     Булево          
	// ТекстПиФ,       Булево   |
	
	Схема = ""; 
	
	// Инициализтруем схему
	Схема = Схема + "@startuml" + Символы.ПС;
	
	// Верхний комментарий в схеме
	Схема = Схема + "'Создано обработкой 1cMShem, " + ТекущаяДатаСеанса() + Символы.ПС;
	Схема = Схема + "'Created by processing 1cMShem, " + ТекущаяДатаСеанса() + Символы.ПС;
	Схема = Схема + "'v.0.01  27-04-2024" + Символы.ПС;
	Схема = Схема + "'GitHub: DmNep/1c-MSchem" + Символы.ПС;
	
	// Задаем заголовок 
	Схема = Схема + "title " + ?(ЗначениеЗаполнено(Объект.ЗаголовокСхемы), Объект.ЗаголовокСхемы + Символы.ПС, "Схема" + Символы.ПС);
	
	// Задаем параметры схемы
	Схема = Схема + Объект.ТипСхемы + Символы.ПС;
	Схема = Схема + Объект.ТипСвязи + Символы.ПС; 
	Схема = Схема + "skinparam ArrowThickness " + Объект.ТолщинаСтрелкиСвязи + Символы.ПС;
	Если ЗначениеЗаполнено(Объект.РастояниеМеждуБлоками) Тогда
		Схема = Схема + "skinparam nodesep " + Объект.РастояниеМеждуБлоками + Символы.ПС; 
	КонецЕсли;
	Если Объект.ВыделятьПиФЖирным Тогда
		Болд = "**";	
	Иначе
		Болд = "";
	КонецЕсли;
	Индекс = 0;
	ИндексВызовов = 0;
	
	//Инициализировать ТЗ внутренних обозначений объектов на схеме
	КС = Новый КвалификаторыСтроки(0);
	Массив = Новый Массив;
	Массив.Добавить(Тип("Строка"));
	ОписаниеТиповС = Новый ОписаниеТипов(Массив, ,КС);
	Массив.Очистить();
	
	ТЗОбозначения = Новый ТаблицаЗначений;
	ТЗОбозначения.Колонки.Добавить("Наименование", ОписаниеТиповС);
	ТЗОбозначения.Колонки.Добавить("Обозначение",  ОписаниеТиповС);
	
	//Определяем наличие контекста
	Если ЗначениеЗаполнено(ТЗПроцедурыИФункции.НайтиСтроки(Новый Структура("Контекст", "&НаКлиенте"))) Тогда
		ЕстьКонтекст = Истина;
	Иначе	
		ЕстьКонтекст = Ложь;
	КонецЕсли;
	Если Объект.ОтображатьКонтекст  Тогда
		Если ЕстьКонтекст Тогда
			ТЗПроцедурыИФункции.Сортировать("Контекст Возр");
			ИдетКонетекстНаКлиенте = Ложь;
			ИдетКонтекстНаСервере = Ложь;
		КонецЕсли;
	КонецЕсли;
	// Формируем объекты
	Если Объект.ВидБлоков = "class" Тогда
		Схема = СформироватьСхему_CLASS(Схема, ТЗСвязи, ТЗПроцедурыИФункции, ЕстьКонтекст, Болд, Индекс, ИндексВызовов, ИдетКонетекстНаКлиенте, ИдетКонтекстНаСервере, ТЗОбозначения);	
	ИначеЕсли Объект.ВидБлоков = "card" Тогда // Доделать 
		Схема = СформироватьСхему_CARD(Схема, ТЗСвязи, ТЗПроцедурыИФункции, ЕстьКонтекст, Болд, Индекс, ИндексВызовов, ИдетКонетекстНаКлиенте, ИдетКонтекстНаСервере, ТЗОбозначения);	
	ИначеЕсли Объект.ВидБлоков = "rectangle" Тогда // Доделать
		Схема = СформироватьСхему_RECTANGLE(Схема, ТЗСвязи, ТЗПроцедурыИФункции, ЕстьКонтекст, Болд, Индекс, ИндексВызовов, ИдетКонетекстНаКлиенте, ИдетКонтекстНаСервере, ТЗОбозначения);	
	Иначе // Доделать и установить дефолт	
	КонецЕсли;
	
	// Вставить нижний комментарий в схему
	Схема = Схема + "footer 1c_MSchem" + Символы.ПС;	
	Схема = Схема + Символы.ПС;
	
	// Завершаем схему
	Схема = Схема + "@enduml"; 
	
	Объект.Схема = Схема;
	
	Возврат Схема;
	
КонецФункции  

Функция СформироватьСхему_CLASS(Схема, ТЗСвязи, ТЗПроцедурыИФункции, ЕстьКонтекст, Болд, Индекс, ИндексВызовов, ИдетКонетекстНаКлиенте, ИдетКонтекстНаСервере, ТЗОбозначения)
	
	Для Каждого СтрокаПиФ Из ТЗПроцедурыИФункции Цикл
		
		//Создаём ректангл
		Если Объект.ОтображатьКонтекст  Тогда
			Если ЕстьКонтекст Тогда
				Если СтрокаПиФ.Контекст = "&НаКлиенте" Тогда 
					Если НЕ ИдетКонетекстНаКлиенте Тогда
						// Создаём ректангл &НаКлиенете
						Схема=Схема+"rectangle ""&НаКлиенте"" as NaKliente {" + Символы.ПС;
						ИдетКонетекстНаКлиенте = Истина;
					КонецЕсли;
				Иначе
					//Завершаем ректангл &НаКлиенте
					Если ИдетКонетекстНаКлиенте Тогда
						Схема=Схема+"}" + Символы.ПС;
						ИдетКонетекстНаКлиенте = Ложь;
					КонецЕсли;
					Если НЕ ИдетКонтекстНаСервере Тогда
						// Создаём ректангл
						Схема=Схема+"rectangle ""&НаСервере"" as NaServere {" + Символы.ПС; 
						ИдетКонтекстНаСервере = Истина;
					КонецЕсли	
				КонецЕсли;	
			КонецЕсли;
		КонецЕсли;
		
		// Создаем класс
		Схема=Схема+"class """+Болд+?(СтрокаПиФ.ЭтоФункция,"Функция ","Процедура ")+Болд+?(Объект.СокращатьДлиннуСтрок,СтрСократить(СтрокаПиФ.Наименование,Объект.ДлиннаСтрок),СтрокаПиФ.Наименование)+""" as class"+Индекс+Символы.ПС;
		
		// Заполняем обозначения классов
		НоваяСтрока = ТЗОбозначения.Добавить();
		НоваяСтрока.Наименование = СтрокаПиФ.Наименование;
		НоваяСтрока.Обозначение = "class" + Индекс; 
		
		Схема = Схема + "{" + Символы.ПС;
		
		//Формируем вызовы
		ОтборТЗ = Новый Структура();
		ОтборТЗ.Вставить("СвязьОт", СтрокаПиФ.Наименование);
		МассивСтрок = ТЗСвязи.НайтиСтроки(ОтборТЗ);
		Если МассивСтрок.Количество() > 0 Тогда
			Для каждого СтрокаМассива Из МассивСтрок Цикл
				
				Если СтрокаПиФ.ЭтоФункция Тогда // Возвраты формируем в самом низу класса
					Если ЗначениеЗаполнено(СтрокаМассива.СтрокаВозврат) Тогда
						Продолжить;
					КонецЕсли;
				КонецЕсли;
				
				Схема = Схема + Символы.Таб + "~{method}" + ?(Объект.СокращатьДлиннуСтрок, СтрСократить(СтрокаМассива.СтрокаВызоваОт, Объект.ДлиннаСтрок), СтрокаМассива.СтрокаВызоваОт) + Символы.ПС;
				
			КонецЦикла;
		КонецЕсли;
		
		// Заполняем обозначения вызовов
		НоваяСтрока = ТЗОбозначения.Добавить();
		НоваяСтрока.Наименование = СтрокаПиФ.Наименование;
		НоваяСтрока.Обозначение = "class" + Индекс; 
		
		
		// Формируем возвраты
		Если СтрокаПиФ.ЭтоФункция Тогда 
			Схема = Схема + Символы.Таб + "-{method}" + ?(Объект.СокращатьДлиннуСтрок, СтрСократить(СтрокаПиФ.Возврат, Объект.ДлиннаСтрок), СтрокаПиФ.Возврат) + Символы.ПС;	
		КонецЕсли;

		// Заполняем обозначения возвратов
		
		
		// Завершаем класс
		Схема = Схема + " }" + Символы.ПС;
		
		// Скрыть значки класса
		Схема = Схема + "hide " + "class"+ Индекс + " circle" + Символы.ПС;
		
		Индекс = Индекс + 1;
		
	КонецЦикла;
	//Завершаем ректангл &НаСервере
	Если Объект.ОтображатьКонтекст  Тогда
		Если ЕстьКонтекст Тогда
			Если ИдетКонтекстНаСервере Тогда
				// Завершаем ректангл &НаСервере
				Схема=Схема+"}" + Символы.ПС;
				ИдетКонтекстНаСервере = Ложь;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	// Создаем связи
	Для Каждого СтрокаСвязь Из ТЗСвязи Цикл
		
		ОтборСвязьОт = Новый Структура();
		ОтборСвязьОт.Вставить("Наименование", СтрокаСвязь.СвязьОт);
		ОбозначСвязьОт = ТЗОбозначения.НайтиСтроки(ОтборСвязьОт);
		ОтборСвязьК = Новый Структура();
		ОтборСвязьК.Вставить("Наименование", СтрокаСвязь.СвязьК);
		ОбозначСвязьК = ТЗОбозначения.НайтиСтроки(ОтборСвязьК);
		// Отрисовываем возвраты и вызовы
		Если СтрокаСвязь.СокрСтрокаВызоваОт = "Возврат" Тогда // Возвраты
			
			ТипСтрелкиВозврата = ?(ЗначениеЗаполнено(Объект.ТипСтрелкиВозврата), Объект.ТипСтрелкиВозврата+",", "");
			Схема=Схема+ОбозначСвязьОт[0].Обозначение+"::"+СтрокаСвязь.СокрСтрокаВызоваОт+" -"+"["+Объект.ЦветСтрелкиВозврата+","+Объект.ТипСтрелкиВозврата+",thickness="+Объект.ТолщинаСтрелкиВозврата+"]"+"> "+ОбозначСвязьК[0].Обозначение+"::"+?(СтрокаСвязь.СвязьКФункции,"Функция","Процедура")+Символы.ПС;
			
		Иначе // вызовы		
			
			ТипСтрелкиСвязи = ?(ЗначениеЗаполнено(Объект.ТипСтрелкиСвязи), Объект.ТипСтрелкиСвязи+",", "");
			Схема=Схема+ОбозначСвязьОт[0].Обозначение+"::"+СтрокаСвязь.СокрСтрокаВызоваОт+" -"+"["+Объект.ЦветСтрелкиСвязи+","+ТипСтрелкиСвязи+"thickness="+Объект.ТолщинаСтрелкиСвязи+"]"+"> "+ОбозначСвязьК[0].Обозначение+"::"+?(СтрокаСвязь.СвязьКФункции,"Функция","Процедура")+Символы.ПС;
			
		КонецЕсли;
		
	КонецЦикла;
	
	// Косметика. Ставит ректанглы контекста в горизонт относительно друг друга
	Если Объект.ОтображатьКонтекст  Тогда
		Если ЕстьКонтекст Тогда
			Схема = Схема + "NaKliente -[hidden]- NaServere" + Символы.ПС;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Схема;
	
КонецФункции 

Функция СформироватьСхему_CARD(Схема, ТЗСвязи, ТЗПроцедурыИФункции, ЕстьКонтекст, Болд, Индекс, ИндексВызовов, ИдетКонетекстНаКлиенте, ИдетКонтекстНаСервере, ТЗОбозначения)
	
	Для Каждого СтрокаПиФ Из ТЗПроцедурыИФункции Цикл
		
		//Создаём ректангл
		Если Объект.ОтображатьКонтекст  Тогда
			Если ЕстьКонтекст Тогда
				Если СтрокаПиФ.Контекст = "&НаКлиенте" Тогда 
					Если НЕ ИдетКонетекстНаКлиенте Тогда
						// Создаём ректангл &НаКлиенете
						Схема=Схема+"rectangle ""&НаКлиенте"" as NaKliente {" + Символы.ПС;
						ИдетКонетекстНаКлиенте = Истина;
					КонецЕсли;
				Иначе
					//Завершаем ректангл &НаКлиенте
					Если ИдетКонетекстНаКлиенте Тогда
						Схема=Схема+"}" + Символы.ПС;
						ИдетКонетекстНаКлиенте = Ложь;
					КонецЕсли;
					Если НЕ ИдетКонтекстНаСервере Тогда
						// Создаём ректангл
						Схема=Схема+"rectangle ""&НаСервере"" as NaServere {" + Символы.ПС; 
						ИдетКонтекстНаСервере = Истина;
					КонецЕсли	
				КонецЕсли;	
			КонецЕсли;
		КонецЕсли;
		
		// Создаем кард
		Схема=Схема+"card """ + ?(СтрокаПиФ.ЭтоФункция,"Функция ","Процедура ") +?(Объект.СокращатьДлиннуСтрок,СтрСократить(СтрокаПиФ.Наименование,Объект.ДлиннаСтрок),СтрокаПиФ.Наименование)+""" as card"+Индекс+ " {" +Символы.ПС;
		
		// Заполняем обозначения
		НоваяСтрока = ТЗОбозначения.Добавить();
		НоваяСтрока.Наименование = СтрокаПиФ.Наименование;
		НоваяСтрока.Обозначение = "card" + Индекс; 
		Индекс = Индекс + 1;
		
		// Формируем вызовы
		ОтборТЗ = Новый Структура();
		ОтборТЗ.Вставить("СвязьОт", СтрокаПиФ.Наименование);
		МассивСтрок = ТЗСвязи.НайтиСтроки(ОтборТЗ);
		Если МассивСтрок.Количество() > 0 Тогда 
			
			Для каждого СтрокаМассива Из МассивСтрок Цикл
				
				Если СтрокаПиФ.ЭтоФункция Тогда // Возвраты формируем в самом низу класса
					Если ЗначениеЗаполнено(СтрокаМассива.СтрокаВозврат) Тогда
						Продолжить;
					КонецЕсли;
				КонецЕсли;
				
				Схема = Схема + Символы.Таб + "card """ + ?(Объект.СокращатьДлиннуСтрок, СтрСократить(СтрокаМассива.СтрокаВызоваОт, Объект.ДлиннаСтрок), СтрокаМассива.СтрокаВызоваОт)+ """ as card"+Индекс+Символы.ПС;
				НоваяСтрока = ТЗОбозначения.Добавить();
				НоваяСтрока.Наименование = СтрокаМассива.СвязьК;
				НоваяСтрока.Обозначение = "card" + Индекс; 
				Индекс = Индекс + 1;
				
			КонецЦикла;
			
		КонецЕсли;
		
		
		//Формируем возвраты
		Если СтрокаПиФ.ЭтоФункция Тогда 
			
			Схема = Схема + Символы.Таб + "card """ + ?(Объект.СокращатьДлиннуСтрок, СтрСократить(СтрокаПиФ.Возврат, Объект.ДлиннаСтрок), СтрокаПиФ.Возврат)+""" as card"+Индекс+Символы.ПС;	
			//Схема = Схема + Символы.Таб + "card """ + ?(Объект.СокращатьДлиннуСтрок, СтрСократить(СтрокаМассива.СтрокаВызоваОт, Объект.ДлиннаСтрок), СтрокаМассива.СтрокаВызоваОт)+ """ as card"+Индекс+Символы.ПС;
			НоваяСтрока = ТЗОбозначения.Добавить();
			НоваяСтрока.Наименование = СтрокаМассива.СвязьК;
			НоваяСтрока.Обозначение = "card" + Индекс; 
			Индекс = Индекс + 1;  
			
		КонецЕсли;  
		
		// Завершаем кард
		Схема = Схема + " }" + Символы.ПС;
		
	КонецЦикла;
	
	//Завершаем ректангл &НаСервере
	Если Объект.ОтображатьКонтекст  Тогда
		Если ЕстьКонтекст Тогда
			Если ИдетКонтекстНаСервере Тогда
				// Завершаем ректангл &НаСервере
				Схема=Схема+"}" + Символы.ПС;
				ИдетКонтекстНаСервере = Ложь;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	// Создаем связи
	Для Каждого СтрокаСвязь Из ТЗСвязи Цикл

		//ОтборСвязьОт = Новый Структура();
		//ОтборСвязьОт.Вставить("Наименование", СтрокаСвязь.СвязьОт);
		//ОбозначСвязьОт = ТЗОбозначения.НайтиСтроки(ОтборСвязьОт);
		//ОтборСвязьК = Новый Структура();
		//ОтборСвязьК.Вставить("Наименование", СтрокаСвязь.СвязьК);
		//ОбозначСвязьК = ТЗОбозначения.НайтиСтроки(ОтборСвязьК);
		//// Отрисовываем возвраты и вызовы
		//Если СтрокаСвязь.СокрСтрокаВызоваОт = "Возврат" Тогда // Возвраты
		//	
		//	ТипСтрелкиВозврата = ?(ЗначениеЗаполнено(Объект.ТипСтрелкиВозврата), Объект.ТипСтрелкиВозврата+",", "");
		//	Схема=Схема+ОбозначСвязьОт[0].Обозначение+"::"+СтрокаСвязь.СокрСтрокаВызоваОт+" -"+"["+Объект.ЦветСтрелкиВозврата+","+Объект.ТипСтрелкиВозврата+",thickness="+Объект.ТолщинаСтрелкиВозврата+"]"+"> "+ОбозначСвязьК[0].Обозначение+"::"+?(СтрокаСвязь.СвязьКФункции,"Функция","Процедура")+Символы.ПС;
		//	
		//Иначе // вызовы		
		//	
		//	ТипСтрелкиСвязи = ?(ЗначениеЗаполнено(Объект.ТипСтрелкиСвязи), Объект.ТипСтрелкиСвязи+",", "");
		//	Схема=Схема+ОбозначСвязьОт[0].Обозначение+"::"+СтрокаСвязь.СокрСтрокаВызоваОт+" -"+"["+Объект.ЦветСтрелкиСвязи+","+ТипСтрелкиСвязи+"thickness="+Объект.ТолщинаСтрелкиСвязи+"]"+"> "+ОбозначСвязьК[0].Обозначение+"::"+?(СтрокаСвязь.СвязьКФункции,"Функция","Процедура")+Символы.ПС;
		//	
		//КонецЕсли;
		
	КонецЦикла;
	
	
	// Косметика. Ставит ректанглы контекста в горизонт относительно друг друга
	Если Объект.ОтображатьКонтекст  Тогда
		Если ЕстьКонтекст Тогда
			Схема = Схема + "NaKliente -[hidden]- NaServere" + Символы.ПС;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Схема;
	
КонецФункции

Функция СформироватьСхему_RECTANGLE(Схема, ТЗСвязи, ТЗПроцедурыИФункции, ЕстьКонтекст, Болд, Индекс, ИндексВызовов, ИдетКонетекстНаКлиенте, ИдетКонтекстНаСервере, ТЗОбозначения)
	
	// Доделать
	Возврат Схема;
	
КонецФункции

